{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started with OpenGL in 2023","text":"<p>Attention</p> <p>This thing is still work in progress...</p> <p>So, what is this?</p> <p>I am very much annoyed by all sorts of OpenGL tutorials out there in the wild. All of them do cover OpenGL and you can get things done, have everything implemented of what you want. But never in a modern way.</p> <p>Most, if not all, use OpenGL 3.3 and that version is quite old. Since then OpenGL moved on quite a bit and got plenty of improvements which should also work on hardware from the past 10 years at least. I'm talking about OpenGL 4.6 and its facilities for Direct State Access or DSA in short. This thing will allow the user to modify state directly - ho ho - thats exactly what DSA stands for - instead of binding stuff to modify,  which is a huge annoyance since you have to somewhat keep mental track of OpenGL's state when doing so, it's an unnecessary pain in the ass.</p> <p>OpenGL 4.6 means people using macs are out of luck. There is simply no support for that version of OpenGL on Apple products.</p> <p>It's not just the old version of OpenGL used in these tutorials, its also the lack of how the development environment should be setup at the beginning to help the user detect problems right away or show how they can help themselves. </p> <p>And there is another big flaw is that they all use float arrays to explain vertices. That's weird and unreadable.</p> <p>Instead of holding hands for each and every step, a tutorial for a somewhat complex topic like OpenGL should explain vertices right from the start, like vertices are most likely more than just positions, they can describe normals, texture coordinates and other things. And that should be explained right from the start. It wont overly complicate a beginners brainbut simplify ALOT of things later, especially troubleshooting.</p> <p>There is also more than just the verticles :) But we will get to it.</p> <p>If you have questions about this thing, I usually hang out on the Graphics Programming discord, feel free to boop You can find the link in the most bottom right corner, in the footer on any page.</p> <p></p> <p>Happy reading.</p>"},{"location":"about/","title":"About OpenGL Getting Started","text":"<p>How to get started with OpenGL in 2023.</p>"},{"location":"about/#credits","title":"Credits","text":"<ul> <li> <p>Frog Logo from: Frog icons created by Freepik - Flaticon</p> </li> <li> <p>Pink Frog below Intro: Frog icons created by Flat Icons - Flaticon</p> </li> <li> <p>Ugly Windows 8 Picture From here</p> </li> </ul>"},{"location":"00-setup/00-setup/","title":"Setup","text":"<p>To render a triangle or the next star citizen on screen we need some application with a window where we can render our world into.</p> <p>Let's try to slowly build up an application which gets improved more and more over each chapter</p> <p>To start we create a small application which handles most common tasks like</p> <ul> <li>creating a window</li> <li>react to input</li> <li>resizing should work in general, we dont want it to be perfect (that's a long story)</li> <li>when it starts up, let it be centered and use 90% of the screen resolution</li> <li><code>Escape</code> will close it</li> <li><code>F11</code> will toggle fullscreen</li> </ul> <p>We should also decide what tools and languages, extensions, editors and or IDEs we pick.</p> <p>We will be using the following languages, programs, extensions and libraries</p> <ul> <li>C++ as our main programming language</li> <li>GLSL our shading programming language, since we need to program some things for the <code>GPU</code></li> <li>CMake will be our project generator, to generate <code>C++</code> projects, which we can build with</li> <li>Visual Studio Code our IDE of choice, into which we will be installing the </li> <li>CMake Tools a Visual Studio extension which will be interfacing with cmake, no need to run cmake via cli then, which is quite nice</li> </ul> <p>Library wise we will be using</p> <ul> <li>GLFW our window and input glue</li> <li>GLAD our opengl functions loader</li> <li>GLM will be our math library</li> <li>STB we will be using this to load images to create textures</li> <li>fastgltf will be used later down the road to load glTF models from disk.</li> </ul> <p>We will be adding some more fancy bits and bops in throughout the tour. Amongst those things are/will be</p> <ul> <li>spdlog to handle logging - i can't stand <code>printf</code> and or <code>std::cout</code> anymore. Logging is a solved problem, no need to reinvent the wheel again.</li> <li>debugbreak a portable debug break implementation which we will be using for our error opengl problem handling</li> <li>Dear Imgui to show off some debug values in the window itself, rather than printeffing some nonsense into the console window, also allows us to build an actual useful UI, could potentially turn into an editor of sorts or just debug controls</li> <li>Tracy a frame profiler which can and will show us some profiling data later on to see how fast things run</li> </ul> <p>I wont be explaining how to install <code>Visual Studio Code</code>, <code>Visual Studio</code>, <code>CLion</code>. I'm sure you can follow the links mentioned above and install the programs yourself according to their instructions.</p> <p>What I will do is go from a everything-in-one file to separating things into what makes sense way</p> <p>So let's start with a basic window setup.</p>"},{"location":"01-basics/01-basic-window/","title":"Basic Window","text":"<p>Find a location of your choice somewhere on your file system.</p> <p>Perhaps something like</p> <p>(Linux) <code>~/Projects/OpenGLGettingStarted</code> (Windows) <code>C:\\Projects\\OpenGLGettingStarted</code></p> <p>And we shall refer to it as the project directory.</p> <p>Now try to reproduce the following structore of the project directory on your system</p> <pre><code>OpenGLGettingStarted\n\u251c\u2500\u2500 lib\n\u2502   \u2514\u2500\u2500 CMakeLists.txt             # here we describe all third party dependencies\n\u2502                                  # like glfw, glad, spdlog, imgui, ...\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 01-01-BasicWindow\n\u2502   \u2502   \u251c\u2500\u2500 Main.cpp               # guess what is in here\n\u2502   \u2502   \u2514\u2500\u2500 CMakeLists.txt         # or here\n\u2514\u2500\u2500 CMakeLists.txt                 # Thats our solution file\n</code></pre> <p>Next step is to fill the <code>CMakeLists</code> files, so that <code>CMake</code> knows what to do.</p> <p>Lets start with <code>lib/CMakeLists.txt</code></p> <p>When we create our first window we have some dependencies, namely <code>GLFW</code>, <code>GLAD</code> and <code>spdlog</code>. <code>CMake</code> has a mechanism called FetchContent which we will be using to pull those dependencies.</p> lib/CMakeLists.txt<pre><code>include(FetchContent)\n\nfind_package(OpenGL REQUIRED)\n</code></pre> <p>Those two line mean, make <code>FetchContent</code> available for us to use, and we would also like to be sure that our platform can handle <code>OpenGL</code> otherwise <code>CMake</code> would fail to prepare the project and let us know. But its unlikely that your system will not support OpenGL. We will also not be supporting anything but a somewhat modern Linux Distribution, like Arch or Fedora or the likes, or Windows. Operating systems from Apple will not be supported, as they lack support for the OpenGL version we are going to target.</p> <p>Next few lines will be pulling the aforementioned dependencies</p> <code>GLFW</code> <p>We want the <code>GLFW</code> sources basically, but we dont need its tests, its example or docs built, we also dont want it to install stuff to somewhere,   just build so that we can link it together with the rest of the application later.   lib/CMakeLists.txt<pre><code>#- GLFW ---------------------------------------------------------------------\n\nFetchContent_Declare(\n    glfw\n    GIT_REPOSITORY https://github.com/glfw/glfw\n    GIT_TAG        3.3.8\n    GIT_SHALLOW    TRUE\n    GIT_PROGRESS   TRUE\n)\nmessage(\"Fetching glfw\")\nset(GLFW_BUILD_TESTS OFF CACHE BOOL \"\")\nset(GLFW_BUILD_DOCS OFF CACHE BOOL \"\")\nset(GLFW_INSTALL OFF CACHE BOOL \"\")\nset(GLFW_BUILD_EXAMPLES OFF CACHE BOOL \"\")\nFetchContent_MakeAvailable(glfw)\n</code></pre></p> <code>GLAD</code> <p>GLAD is a functions loader for <code>OpenGL</code>. It takes the <code>OpenGL</code> specification xml for the targetted version and generates function bindings for us, which we need to load   when we have a render context available. What that is I will explain later.   lib/CMakeLists.txt<pre><code>FetchContent_Declare(\n    glad\n    GIT_REPOSITORY https://github.com/Dav1dde/glad.git\n    GIT_SHALLOW    TRUE\n    GIT_PROGRESS   TRUE\n)\n\nFetchContent_GetProperties(glad)\nif(NOT glad_POPULATED)\n    message(\"Fetching glad\")\n    FetchContent_Populate(glad)\n    set(GLAD_PROFILE \"core\" CACHE STRING \"OpenGL profile\")\n    set(GLAD_API \"gl=4.6\" CACHE STRING \"API type/version pairs, like \\\"gl=4.6\\\", no version means latest\")\n    set(GLAD_GENERATOR \"c\" CACHE STRING \"Language to generate the binding for\")\n    set(GLAD_EXTENSIONS \"GL_ARB_bindless_texture\" CACHE STRING \"Extensions to take into consideration when generating the bindings\")\n    add_subdirectory(${glad_SOURCE_DIR} ${glad_BINARY_DIR})\nendif()\n</code></pre></p> <code>spdlog</code> <p>a logging framework which provides structured logging facilities. No more weird <code>printf</code> or <code>std::cout</code>.   lib/CMakeLists.txt<pre><code>FetchContent_Declare(\n    spdlog\n    GIT_REPOSITORY https://github.com/gabime/spdlog.git\n    GIT_TAG        v1.10.0\n    GIT_SHALLOW    TRUE\n    GIT_PROGRESS   TRUE\n)\n\nmessage(\"Fetching spdlog\")\nFetchContent_MakeAvailable(spdlog)\n</code></pre></p> <p>Next one is <code>CMakeLists.txt</code> in our project directory.</p> <p>That is our main project file.</p> CMakeLists.txt<pre><code>project(OpenGLGettingStarted)\n\nset(CMAKE_CXX_STANDARD 23)\n\nadd_subdirectory(lib)\n</code></pre> <p>It declares the project name, which c++ standard we want to target and which targets we want to add. Those are a) our dependencies which are declared in <code>lib/CMakeLists.txt</code> hence the <code>add_directory(lib)</code> line as well as b) our actual projects we are going to write in this guide.</p> <p>Let's put in our first project in too, right below <code>add_subdirectory(lib)</code></p> <pre><code>add_subdirectory(src/00-BasicWindow)\n</code></pre> <p>And then we move on to BasicWindow's CMakeLists.txt and Main.cpp</p> src/01-01-BasicWindow/CMakeLists.txt<pre><code>add_executable(01-01-BasicWindow\n    Main.cpp\n)\n\nif (MSVC)\n    target_compile_options(01-01-BasicWindow PRIVATE /W3 /WX)\nelse()\n    target_compile_options(01-01-BasicWindow PRIVATE -Wall -Wextra -Werror)\nendif()\n\ntarget_include_directories(spdlog PUBLIC include)\n\ntarget_link_libraries(01-01-BasicWindow PRIVATE glad glfw spdlog)\n</code></pre> <p>Again declare a target, in this case <code>01-01-BasicWindow</code> (I try to keep the docs pages in sync with the target names to aid my brain while writing this). Specify which cpp file/unit to build.</p> <p>Then there is a small block which detects whether you are using Microsoft's C++ Compiler or not, and configure the compiler to always treat warnings as errors.</p> <p>Then we make <code>spdlog</code>'s include directory available to the target and link the program with our dependencies.</p> <p>Finally we can start working on the first c++ parts. We will keep everything in one file, to create a window and react to keyboard input <code>ESC</code> and <code>F11</code>.</p> <p>Let's start.</p>"},{"location":"01-basics/01-basic-window/#maincpp","title":"Main.cpp","text":"<p>I like to use <code>int32_t</code>, <code>uint16_t</code> over types/aliases like <code>int</code>, or <code>ushort</code>. For that we include <code>cstdint</code>.</p> <p>We also include glad and glfw header as well as spdlog's. When it comes to glad and glfw we need to be careful here to include glad before glfw. C++ is weird and sometimes the order of includes is important, because certain compiler definitions/switches are declared somewhere else which are picked up by something else.</p> <p>That's one of the cases here.</p> <p>Plus the usual entry point for your bog standard c/c++ program.</p> <p>It all should look like this:</p> <pre><code>#include &lt;cstdint&gt;\n\n#include &lt;glad/glad.h&gt;\n#include &lt;GLFW/glfw3.h&gt;\n\n#include &lt;spdlog/spdlog.h&gt;\n\nint main(int32_t argc, char* argv[])\n{\n    return 0;   \n}\n</code></pre> <p>You might want to reconfigure the project here, to be sure all deps are loaded and <code>CMake</code> knows how to build all this stuff. in <code>VSCode</code> press <code>Ctrl+Shift+p</code> and look for <code>CMake: Delete Cache and Reconfigure</code>. It is probably called very similar in <code>Clion</code> or <code>Visual Studio</code>.</p> <p><code>VSCode</code> will probably say something like this afterwards:</p> <pre><code>[cmake] -- Build files have been written to: /home/deccer/Projects/OpenGL-Getting-Started/build\n</code></pre> <p>If not you most likely goofed something up, please check if you have setup the project structure as I described or if there is a typo somewhere.</p> <p>If you  try to build it as is. You should get an error saying something like that:</p> <pre><code>error: unused parameter \u2018argc\u2019 [-Werror=unused-parameter]\n</code></pre> <p>And another one for <code>argv</code> because we dont really use them anywhere. We still want to treat warnings as errors, but we cant really fix anything here, instead we tell the compiler that we are aware of it, and annotate the 2 parameters with an attribute called <code>[[maybe_unused]]</code>.</p> <p>The whole thing should look like</p> <pre><code>#include &lt;cstdint&gt;\n\n#include &lt;glad/glad.h&gt;\n#include &lt;GLFW/glfw3.h&gt;\n\n#include &lt;spdlog/spdlog.h&gt;\n\nint main(\n    [[maybe_unused]] int32_t argc,\n    [[maybe_unused]] char* argv[])\n{\n    return 0;   \n}\n</code></pre> <p>If you build now, it should succeed.</p> <p>Next step, create a window. In order to create a window we have to do a few things first, because we want a window which provides us with a render context. To tell <code>GLFW</code> what parameters we want we have to give it a few hints, literally.</p> <p>Well, first we initialize <code>GLFW</code> itself by calling <code>glfwInit</code> and check its result value. It could fail because for some reason we didnt link glfw with our project or so.</p> src/01-01-BasicWindow/Main.cpp<pre><code>    if (glfwInit() == GLFW_FALSE)\n    {\n        spdlog::error(\"Glfw: Unable to initialize\");\n        return 1;\n    }\n</code></pre> <p>This is also the first time we use <code>spdlog</code>, instead of <code>printf</code> or <code>std::cout</code>.</p> <p>Now the hints. We want to use <code>OpenGL</code>, we would like to target OpenGL 4.6 and its core profile. On top of that, we want he window be resizable, and come with window decoration (border, top window bar and system menu/buttons)</p> src/01-01-BasicWindow/Main.cpp<pre><code>    glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_API);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\n    glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE);\n    glfwWindowHint(GLFW_DECORATED, GLFW_TRUE);\n    glfwWindowHint(GLFW_SCALE_TO_MONITOR, GLFW_TRUE);\n</code></pre> <p>When we create the window we can specify its width and height. Earlier I mentioned that I like my windows centered, and in the case of the OpenGLGettingStarted thing also be 80% of whatever resolution you use at the moment. Therefore we ask the system about the current resolution to derive the window dimensions from.</p> src/01-01-BasicWindow/Main.cpp<pre><code>    auto primaryMonitor = glfwGetPrimaryMonitor();\n    auto videoMode = glfwGetVideoMode(primaryMonitor);\n\n    auto screenWidth = videoMode-&gt;width;\n    auto screenHeight = videoMode-&gt;height;\n\n    auto windowWidth = static_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(screenWidth) * 0.8f);\n    auto windowHeight = static_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(screenHeight) * 0.8f);\n</code></pre> <p>Then we can actually create the window, by passing the window dimensions and a title. We don't want to use exclusive fullscreen. </p> src/01-01-BasicWindow/Main.cpp<pre><code>    auto windowHandle = glfwCreateWindow(windowWidth, windowHeight, \"OpenGL - Getting Started\", nullptr, nullptr);\n    if (windowHandle == nullptr)\n    {\n        const char* errorDescription = nullptr;\n        auto errorCode = glfwGetError(&amp;errorDescription);\n        if (errorCode != GLFW_NO_ERROR)\n        {\n            spdlog::error(\"GLFW: Unable to create window Details_{}\", errorDescription);\n        }\n        return 1;\n    }\n</code></pre> <p>Window creation can fail for various reasons, that's why we are going to ask it for an actual error message, if its not able to create a window.</p> <p>By the way you can always check <code>GLFW</code>'s docs for more information.</p> <p>Now we have a window, but I like it centered, as mentioned before, <code>GLFW</code> doesn't automatically center the window for us unlike <code>SDL2</code> (another library providing windowing and input glue, amongst other things)</p> <p>So that's what we will be doing here</p> src/01-01-BasicWindow/Main.cpp<pre><code>    int32_t monitorLeft = 0;\n    int32_t monitorTop = 0;\n    glfwGetMonitorPos(primaryMonitor, &amp;monitorLeft, &amp;monitorTop);\n    glfwSetWindowPos(windowHandle, screenWidth / 2 - windowWidth / 2 + monitorLeft, screenHeight / 2 - windowHeight / 2 + monitorTop);\n</code></pre> <p>We can also interact with the window now, that means send keyboard input, or mouse events, resize the window, minify or maxify it to mention a few. We will focus on 2 for now.</p> <p>Resizing and keyboard input.</p> <p>To be able to get a feedback when a window has been resized or key pressed/released we need to hook up 2 callbacks using the following calls.</p> <p>Resize first. Windows consist of roughly 2 major things. A non client area and the client area. The former is everything like border which can be 1-n pixels thick, and the title bar which has a caption, the usual buttons to minimize, maximize and close a window and the system menu. The latter is usually the part wrapped by the non client area. The client area is the space we have available to draw our stuff to/on. Now when a window gets resized, the client area is resized as well, automatically.</p> <p>Perhaps a ugly picture helps.</p> <p></p> <p>Since we only want to focus on that area in particular we will setup a callback which will listen to that change so that we dont have to worry about calculating weird offsets/margins when we have to take border sizes and window title bars into account when it comes to sizes.</p> <p><code>GLFW</code> also calls that non client area a framebuffer, and its resize callback FramebufferSizeCallback.</p> src/01-01-BasicWindow/Main.cpp<pre><code>    glfwSetFramebufferSizeCallback(windowHandle, [](\n        [[maybe_unused]] GLFWwindow* window,\n        int32_t framebufferWidth,\n        int32_t framebufferHeight)\n    {\n        glViewport(0, 0, framebufferWidth, framebufferHeight);\n    });\n</code></pre> <p>Resizing the framebuffer will come in handy later, when we have to adjust your projection matrices and framebuffer attachments (we will talk about what it is later)</p> <p>We also need some form of handling keyboard input. <code>GLFW</code> has a callback for that as well</p> src/01-01-BasicWindow/Main.cpp<pre><code>    glfwSetKeyCallback(windowHandle, [](\n        GLFWwindow* window,\n        int32_t key,\n        [[maybe_unused]] int32_t scancode,\n        int32_t action,\n        [[maybe_unused]] int32_t mode)\n    {\n        if (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS)\n        {\n            glfwSetWindowShouldClose(window, GLFW_TRUE);\n        }\n    });\n</code></pre> <p>The window should close when we press <code>ESC</code>, thats what we do here, tell the window that next time its events are updated, it will see that we want it to close and it closes. We will see that exact evalution few lines below from here in a second.</p> <p>The next two lines are important.</p> <p>OpenGL is a state machine. An OpenGL context holds that state. The state contains information such as which textures are bound to which texture units, which attachments the current framebuffer object has and things like that.</p> <p>When you set the current context, you are switching all the state from the old context to the new context.</p> <p>We dont have an old context nor another one than just this one, but thats what you have to call at least once in your application. </p> src/01-01-BasicWindow/Main.cpp<pre><code>    glfwMakeContextCurrent(windowHandle);\n    gladLoadGLLoader((GLADloadproc)glfwGetProcAddress);\n</code></pre> <p>The call after <code>glfwMakeContextCurrent</code> is as important, as it loads all necessary OpenGL function pointers, so that we can actually use them.</p> <p>Then we will be setting some of that mentioned OpenGL state explicitly to their default values.</p> src/01-01-BasicWindow/Main.cpp<pre><code>    glEnable(GL_FRAMEBUFFER_SRGB);\n    glEnable(GL_CULL_FACE);\n    glCullFace(GL_BACK);\n    glFrontFace(GL_CCW);\n\n    glClearColor(0.35f, 0.76f, 0.16f, 1.0f);\n    glClearDepthf(1.0f);\n</code></pre> <p>TODO</p> <p>Explain the states, explain srgb here?</p>"},{"location":"01-basics/01-basic-window/#main-loop","title":"Main Loop","text":"<p>Next block, we are also almost finished, is the so called game loop, a simple loop which runs as long as the window is upen. It refreshes all state <code>GLFW</code> knows about like which keys have been pressed, where is the window being moved to or resized upto what dimensions or whether a joystick has been plugged in amongst other things.</p> <p><code>GLFW</code> created a double buffered window for us, and the <code>glfwSwapBuffers</code> swaps those buffers whenever they are ready to be swapped.</p> src/01-01-BasicWindow/Main.cpp<pre><code>    while (!glfwWindowShouldClose(windowHandle))\n    {\n        glfwPollEvents();\n\n        glfwSwapBuffers(windowHandle);\n    }\n</code></pre> <p>That game loop is the place where most of the magic happens. You update your game objects, read key from the keyboard and mouse, queue sounds to be played, receive network packets perhaps, and most importantly render your virtual world.</p> <p>TODO</p> <p>Explain swapping buffers a bit more here</p> <p>What happens after we exit that game loop?</p> <p>Not much, as there usually nothing else after the program ends, we clean up. Destroy the main window and terminate <code>GLFW</code> so that it can clean up its internal state.</p> <p>And then we return to the `OS``.</p> <p>In the next chapter we will add all the necessary things to render a triangle.</p>"},{"location":"01-basics/02-basic-window-and-triangle/","title":"Basic Window With Triangle","text":"<p>In this chapter we will be adding quite a bit of code, code which will support us finding errors and identifying problems, because sooner or later we will run into them and we should figure out how to help ourselves as soon as possible.</p> <p>The amount of code can be a bit overwhelming, but bear with me. It's also not THAT bad.</p> <p>First of all, quick recap of our project structure from the previous chapter.</p> <pre><code>OpenGLGettingStarted\n\u251c\u2500\u2500 lib\n\u2502   \u2514\u2500\u2500 CMakeLists.txt             # here we describe all third party dependencies\n\u2502                                  # like glfw, glad, spdlog, imgui, ...\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 01-01-BasicWindow\n\u2502   \u2502   \u251c\u2500\u2500 Main.cpp               # guess what is in here\n\u2502   \u2502   \u2514\u2500\u2500 CMakeLists.txt         # or here\n\u2514\u2500\u2500 CMakeLists.txt                 # Thats our solution file\n</code></pre> <p>We need to extend it so that we will create a new directory in <code>src</code> and call it <code>01-02-BasicWindowAndTriangle</code>. We copy paste <code>Main.cpp</code> and <code>CMakeLists.txt</code> from <code>src/01-01-BasicWindow</code> into the newly created directory and make sure to adjust <code>CMakeLists.txt</code> accordingly - it should just be naming things for now - I hope you can figure that out by yourself.</p> <p>Now is probably a good time to talk about the</p>"},{"location":"01-basics/02-basic-window-and-triangle/#graphics-pipeline","title":"Graphics Pipeline","text":""},{"location":"01-basics/02-basic-window-and-triangle/#vertex-input","title":"Vertex Input","text":"<p>DirectX is calling it <code>Input Assembly</code>, I also kind of like this name better for some reason (RenderDoc which I explain later also calls it <code>Input Assembly</code>). Anyway. Our models and meshes we want to render are made out of vertices. We may want to render them as lines, points, or triangle fans, but for now we'll do a triangle list, and that is setup here in the input assembly or vertex input stage.</p> <p>I might use <code>Input Assembly</code> or <code>IA</code> instead of vertex input when I elaborate on things, out of habit, but I mean <code>Vertex Input</code></p> <p>You might have seen export options in tools such as Blender or perhaps fiddled with libraries like Assimp where options like <code>Triangulate Vertices</code> exist of some form. That's why. Artists might use \"quads\" or other topologies, but the graphics card likes to munch on triangles.</p> <p>That is also a good point to introduce a construct like <code>Vertex</code> or to be more specific in our case a <code>VertexPositionColor</code> construct.</p> <pre><code>struct VertexPositionColor\n{\n    glm::vec3 Position;\n    glm::vec3 Color;\n};\n</code></pre> <p>A vertex is each point in a model or mesh describing its position in model space amongst other attributes, like color in this specific one. Vertices can also hold other attributes such as texture coordinates (aka <code>UVs</code>), normals, tangents or anything else really.</p> <p>It usually depends on what kind of thing you are actually trying to implement here but in most cases its one or more of the aforementioned attributes. We will be using textures and normals later on for instance.</p> <p>Speaking of instance. Models and meshes can also be \"instanced\" by the <code>GPU</code>. Think of copies of the same model or mesh but placed somewhere else, like a Tree in a forest, grass or an asteroid in an asteroid field. Information about those instances can also be encoded into the Vertex, but we will not make use of it in this guide because there are better means to do so IMHO but I wanted to mention it briefly. How instancing works I will also explain later.</p> <p>Model or Mesh</p> <p>...are terms which can be used interchangably here, both are collections of vertices mainly. I might find a better term for it later and adjust this guide accordingly.</p> <p>Back to the <code>Vertex Input</code>. We have our vertices, which we might have been loaded from a model file  or are arranged in a list to make up some primitive shapes like a box or sphere. We also have our primitive type which can be point, line, line-strip, triangle-strip, triangle-fan and triangle.</p> <p>Our vertices are usually collections of <code>Vertex</code> and those are sent over to the <code>GPU</code> that they can be used to render them.</p> <p>Let's declare that thing right after we initialized <code>OpenGL</code> with default values after <code>glClearDepth(1.0f);</code></p> <pre><code>    std::array&lt;VertexPositionColor, 3&gt; vertices =\n    {\n        VertexPositionColor{ .Position = glm::vec3(-0.5f, +0.5f, 0.0f), .Color = glm::vec3(1.0f, 0.2f, 1.0f) },\n        VertexPositionColor{ .Position = glm::vec3(+0.0f, -0.5f, 0.0f), .Color = glm::vec3(0.2f, 1.0f, 1.0f) },\n        VertexPositionColor{ .Position = glm::vec3(+0.5f, +0.5f, 0.0f), .Color = glm::vec3(1.0f, 1.0f, 0.2f) }        \n    };\n</code></pre> <p>Those collections are stored in a buffer. The <code>GPU</code> can access them to retrieve whatever information is stored in them, in this case vertices and the buffer in this specific instance is called <code>vertex buffer</code>.</p> <p>Buffers are a generic <code>OpenGL</code> object, referring to a blob of memory with size if you will.</p> <p>Explain buffers here, perhaps in more detail</p> <p>To create a buffer we simply call these functions and stuff the vertex collection right into it. </p> <pre><code>    uint32_t vertexBuffer = 0;\n    glCreateBuffers(1, &amp;vertexBuffer);\n</code></pre> <p>Elaborate</p> <p>Explain immutable storage and the difference to the old glBindBuffer stuff?</p> <p>We need one more thing to complete the Vertex Input stage. We need it to tell the <code>GPU</code> how to interpret the data coming from the vertex buffer(s).</p> <p>That thing is unfortunately named <code>Vertex Array Object</code> (or <code>VAO</code> in short) in OpenGL. God knows why, but we have to deal with it.</p> <p>I have a better name for it. I would like to call it <code>Input Layout</code> (I might refer to it as <code>IL</code> too). It makes much more sense to me because the input layout as the name suggests describes a layout of sorts for some input. And if  you remember we are in the <code>Vertex Input</code> stage still. </p> <p>The input layout is created as follows:</p> <pre><code>    uint32_t inputLayout = 0;\n    glCreateVertexArrays(1, &amp;inputLayout);\n\n    glEnableVertexArrayAttrib(inputLayout, 0);\n    glVertexArrayAttribFormat(inputLayout, 0, 3, GL_FLOAT, GL_FALSE, offsetof(VertexPositionColor, Position));\n    glVertexArrayAttribBinding(inputLayout, 0, 0);        \n\n    glEnableVertexArrayAttrib(inputLayout, 1);\n    glVertexArrayAttribFormat(inputLayout, 1, 3, GL_FLOAT, GL_FALSE, offsetof(VertexPositionColor, Color));\n</code></pre> <p>A vertex may have \"attributes\" that describe its constituent data.</p> <p>For instance, our vertex's first attribute is \"position,\" consisting of 3 floating point components. We specify that the 0th attribute of <code>inputlayout</code> consists of 3 floats (<code>GL_FLOAT</code>), which are not normalized (<code>GL_FALSE</code>), and then specify the offset of the <code>Position</code> data within our <code>VertexPositionColor</code> struct:</p> <p><code>glVertexArrayAttribFormat(inputLayout, 0, 3, GL_FLOAT, GL_FALSE, offsetof(VertexPositionColor, Position));</code></p> <p>Elaborate</p> <p>Explain AOS/SOA/Interleaved/NonInterleaved VertexFormat?</p> <p>Last but not least, we associate our vertex buffer with our input layout.</p> <pre><code>    glVertexArrayVertexBuffer(inputLayout, 0, vertexBuffer, 0, sizeof(VertexPositionColor));\n</code></pre> <p>Exercise</p> <p>Can you create a vertex type similar to our <code>VertexPositionColor</code> which has 2 more attributes. I also want normals and tangents. The former usually is a <code>glm::vec3</code> the latter a <code>glm::vec4</code>. How would you name it? And how would the corresponding input layout look like?</p>"},{"location":"01-basics/02-basic-window-and-triangle/#vertex-shader","title":"Vertex Shader","text":"<p>The Vertex shader takes a single vertex as the input. It's main purpose is to transform coordinates from one coordinate system into another. It usually takes your model vertex positions and transforms them into normalized device coordinates (x direction: [-1.0f, 1.0f], y direction: [-1.0f, 1.0f]). That usually happens via matrix manipulations which we will cover later.</p> <p>The actual coordinates on the screen are achieved when the normalized device coordinates are transformed to screen coordinates via <code>glViewport</code>. While writing this I noticed a bubu I made earlier. Its not really a problem but I  would like it to be somewhat proper. <code>glViewport</code> is only called when we resize the window, we never set it initially and <code>GLFW</code> is also not calling the framebufferresize callback after it created the window. Lets add the following lines after line 144 where we call <code>gladLoadGLLoader(...)</code>.</p> <pre><code>    int32_t framebufferWidth = 0;\n    int32_t framebufferHeight = 0;\n    glfwGetFramebufferSize(windowHandle, &amp;framebufferWidth, &amp;framebufferHeight);\n    glViewport(0, 0, framebufferWidth, framebufferHeight);\n</code></pre> <p>Shaders are programs which run on the <code>GPU</code>. We can modify them in order to let them do what we want. In case of the vertex shader we want to it to position our vertices and pass the color of each vertex onto the fragment shader (will talk about it in a second). Therefore the shader code looks rather simple.</p> <pre><code>    auto vertexShaderSource = R\"glsl(\n        #version 460 core\n\n        out gl_PerVertex\n        {\n            vec4 gl_Position;\n        };\n\n        layout (location = 0) in vec3 i_position;\n        layout (location = 1) in vec3 i_color;\n\n        layout (location = 0) out vec3 v_color;\n\n        void main()\n        {\n            gl_Position = vec4(i_position, 1.0);\n            v_color = i_color;\n        })glsl\"sv;\n</code></pre> <p>For this example I put the shader code right into the actual source code, usually those programs are separate files, stored on disk somewhere with a proper filename to indicate which program it is.</p> <p>File naming conventions</p> <p>I use the following naming convention for all my shader files</p> <p>MeaningfulName.<code>xx</code>.glsl</p> <p>Where xx stands for the shader, or its shortcut rather.</p> <p>Examples:</p> <pre><code>FullScreenTriangle.vs.glsl - a vertex shader\n\nCullVisibility.fs.glsl - a fragment shader\n\nCullLights.cs.glsl - a compute shader\n</code></pre> <p>Other people might use .vert, .frag, .comp or .vs, .fs, .cs as file extensions, that will most likely trip your OS into believing those are not shaders but post script files or otherwise, Code highlighting tools may or may not like those files right away or require configuration. Pick your poison.</p> <p>As you can see we take in input, and we return values in the vertex shader. I wonder if you also notice the 2 input attributes <code>i_position</code> and <code>i_color</code>. Does this look familiar to you? Our input layout also has those 2 attributes. Even the data type matches... <code>vec3</code> ... a thing consisting of 3 floats. Now the name \"input layout\" should even make more sense, <code>VertexArrayObject</code> really does not, right?</p> <p>We write the current position of the vertex into <code>gl_Position</code> and pass the vertex color onto the next stage in form of a so called varying (hence the prefix <code>v_</code>).</p> <p>The shader source along wont do anything, we need to construct a program, compile and link it, check if the compilation actually worked.</p> <p>For that let's write a little helper function, since we will be using it to create the fragment shader later too, and we can practice a little code reuse already.</p> <pre><code>std::expected&lt;uint32_t, std::string&gt; CreateProgram(\n    uint32_t shaderType,\n    std::string_view shaderSource)\n{\n    const char* shaderSourcePtr = shaderSource.data();\n    auto shaderProgram = glCreateShaderProgramv(shaderType, 1, &amp;shaderSourcePtr);\n    auto linkStatus = 0;\n    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;linkStatus);\n    if (linkStatus == GL_FALSE)\n    {\n        auto infoLogLength = 0;\n        char infoLog[1024];\n        glGetProgramInfoLog(shaderProgram, 1024, &amp;infoLogLength, infoLog);\n\n        return std::unexpected(infoLog);\n    }\n\n    return shaderProgram;\n}\n</code></pre> <p>Let's put it below where we declared our <code>VertexPositionColor</code> type.</p> <p>What does it do? It creates an <code>OpenGL</code> object to represent a program, we will pass the shader source along, as well as what shader program exactly, vertex shader, fragment shader or compute shader. It will compile and link the program and check whether there was a problem or not. If there was problem it will be returned as error message and if everything was alright we will get back the program itself.</p> <p>The vertex shader itself:</p> <pre><code>    auto vertexShaderSource = R\"glsl(\n        #version 460 core\n\n        out gl_PerVertex\n        {\n            vec4 gl_Position;\n        };\n\n        layout (location = 0) in vec3 i_position;\n        layout (location = 1) in vec3 i_color;\n\n        layout (location = 0) out vec3 v_color;\n\n        void main()\n        {\n            gl_Position = vec4(i_position, 1.0);\n            v_color = i_color;\n        })glsl\"sv;\n</code></pre> <p>And here is how we create a program out of it.</p> <pre><code>    auto vertexShaderResult = CreateProgram(GL_VERTEX_SHADER, vertexShaderSource);\n    if (!vertexShaderResult.has_value())\n    {\n        spdlog::error(\"OpenGL: Failed to compile vertex shader: {}\", vertexShaderResult.error());\n        return 1;\n    }\n    uint32_t vertexShader = vertexShaderResult.value();\n</code></pre>"},{"location":"01-basics/02-basic-window-and-triangle/#tesselation-control-stage","title":"Tesselation Control Stage","text":"<p>We will not cover TCS, since its outdated tech and not recommended to be used anymore</p> <p>However if you are curious what is is and how it can be used ogldev has videos on this and the following 2 stages.</p>"},{"location":"01-basics/02-basic-window-and-triangle/#tesselation-evaluation-stage","title":"Tesselation Evaluation Stage","text":"<p>We will not cover TES, since its outdated tech and not recommended to be used anymore</p>"},{"location":"01-basics/02-basic-window-and-triangle/#geometry-shader","title":"Geometry Shader","text":"<p>We will not cover geometry shaders, since its outdated tech and not recommended to be used anymore</p>"},{"location":"01-basics/02-basic-window-and-triangle/#rasterizer-stage","title":"Rasterizer Stage","text":"<p>This stage receives the output of the vertex shading (remember we ignored TCS, TES, GS) stage. Here is where the primitives (triangle, points, lines) are mapped to screen positions. to produce fragments for the fragment shader to process.</p> <p>The Rasterizer also clips fragments which are not part of the viewport.</p> <p>Other things affecting the rasterizer are face culling and face winding. The former defaults to no face culling on opengl, that means front and backfaces are rasterized, but usually back face culling is enabled. This comes in handy for closed objects like a cube, where you dont need to render the insides of it when you never go into the cube. The other thing, face winding, is there to tell in which order the vertices of primitives are processed. Clockwise (<code>CW</code>) or Counterclockwise <code>CCW</code>, OpenGL's default is <code>CCW</code>.</p> <p>We did setup those things too here</p> <pre><code>    glEnable(GL_CULL_FACE);\n    glCullFace(GL_BACK);\n    glFrontFace(GL_CCW);\n</code></pre>"},{"location":"01-basics/02-basic-window-and-triangle/#fragment-shader","title":"Fragment Shader","text":"<p>The fragment shader takes the fragments from the rasterizer stage and \"colors\" them in this stage. That's what most of the time is happening here anyway.</p> <p>The fragment shader is also an object we create, similar to the vertex shader</p> <p>The fragment shader itself</p> <pre><code>    auto fragmentShaderSource = R\"glsl(\n        #version 460 core\n\n        layout (location = 0) in vec3 v_color;\n\n        layout (location = 0) out vec4 out_color;\n\n        void main()\n        {\n            out_color = vec4(v_color, 1.0);\n        })glsl\"sv;\n</code></pre> <p>And we also create a program out of it like so</p> <pre><code>    auto fragmentShaderResult = CreateProgram(GL_FRAGMENT_SHADER, fragmentShaderSource);\n    if (!fragmentShaderResult.has_value())\n    {\n        spdlog::error(\"OpenGL: Failed to compile fragment shader: {}\", fragmentShaderResult.error());\n        return 1;\n    }\n    uint32_t fragmentShader = fragmentShaderResult.value();\n</code></pre> <p>But with just those 2 programs we cannot do much. We need to hook them up in a program pipeline.</p> <p>With shader program pipelines shader programs can be mix and matched together like you want, without having to recreate pairs of vertex/fragment shaders for instance, ie. Create 1 vertex shader program and combine it with various fragment shaders, like for post effects.</p> <p>Let's create that program pipeline</p> <pre><code>    uint32_t programPipeline = 0;\n    glCreateProgramPipelines(1, &amp;programPipeline);\n    glUseProgramStages(programPipeline, GL_VERTEX_SHADER_BIT, vertexShader);\n    glUseProgramStages(programPipeline, GL_FRAGMENT_SHADER_BIT, fragmentShader);\n</code></pre>"},{"location":"01-basics/02-basic-window-and-triangle/#output-merger-fb","title":"Output Merger (\"FB\")","text":"<p>I would like to call this stage <code>Output Merger</code>, just like Microsoft did name this stage in DirectX. It makes more sense since in this stage all relevant output is merged into the final output. This could mean output to single or multiple framebuffers, while alpha, blending, stencil and depth testing is happening.</p>"},{"location":"01-basics/02-basic-window-and-triangle/#compute-pipeline","title":"Compute Pipeline","text":"<p>Compute Pipeline</p> <p></p> <p>Compute shaders are general purpose programs which can do whatever you like, they dont specialize in rasterization like stuff does in the graphics pipeline. We might take a look at compute shaders later on.</p>"},{"location":"01-basics/02-basic-window-and-triangle/#final-draw-call","title":"Final Draw Call","text":"<p>We setup our rendering pipeline, loaded shaders, initialized vertex buffers and inputlayout, what is left to do is tell <code>OpenGL</code> to use those things in order to render the triangle.</p> <p>The shaders are associated with <code>programPipeline</code> and the vertex buffer is associated with the <code>inputLayout</code>. We bind them and issue the actual draw call.</p> <pre><code>    glClearColor(0.79f, 0.006f, 0.1332f, 1.0f);\n\n    while (!glfwWindowShouldClose(windowHandle))\n    {\n        glfwPollEvents();\n\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        glBindVertexArray(inputLayout);\n        glBindProgramPipeline(programPipeline);\n        glDrawArrays(GL_TRIANGLES, 0, vertices.size());\n\n        glfwSwapBuffers(windowHandle);\n    }\n</code></pre> <p>If you compile and run you should see this:</p> <p></p>"},{"location":"01-basics/02-basic-window-and-triangle/#cleanup","title":"Cleanup","text":"<p>It goes without saying that you should clean up after yourself.</p> <p>We do it in the opposite direction of when we created all those things.</p> <pre><code>    glDeleteProgram(fragmentShader);\n    glDeleteProgram(vertexShader);\n    glDeleteProgramPipelines(1, &amp;programPipeline);\n\n    glDeleteBuffers(1, &amp;vertexBuffer);\n    glDeleteVertexArrays(1, &amp;inputLayout);\n\n    glfwDestroyWindow(windowHandle);\n    glfwTerminate();\n</code></pre>"},{"location":"02-debugging/01-debugging/","title":"Debugging","text":"<p>This will be super short.</p> <p>You should make yourself familiar with the debugger of your choice. Some come with or are built into integrated development environments, some are standalone programs.</p> <p>Visual Studio</p> <p>GDB Documentation GDB Cheat Sheet Valgrind</p> <p>Those tools help you to find out whether your code works as intended or produces the right values. Get used to using it, before asking for help anywhere else. A lot of places/forums/discord servers also assume that you tried helping yourself first.</p> <p>This should cover the pure code side, unrelated to <code>OpenGL</code> or any other graphics API.</p> <p>It also helps to take a look at the OpenGL Specification. It will show you what is valid and what isnt valid to call. Which formats and parameters etc are possible. Make sure to bookmark this document. Same applies to the GLSL Specification. It contains everything related to GLSL, parameters, attributes, identifiers and keywords. This should also go into your bookmarks.</p> <p>In the next chapter I will show you how you can ask <code>OpenGL</code> to be nice to you.</p>"},{"location":"02-debugging/02-debug-callback-exercise-01/","title":"Exercise 1","text":""},{"location":"02-debugging/02-debug-callback-exercise-01/#debug-callback-exercise-1","title":"Debug Callback Exercise 1","text":"<ul> <li>Go to the debug callback and set a break point at the end of the function</li> <li>Go to the main loop and find the <code>glClear(GL_COLOR_BUFFER_BIT);</code> call.</li> <li>Replace it with <code>glClear(0xFFF);</code> </li> <li>Compile and run</li> </ul> <p>What do you see?</p> <pre><code>[2023-11-23 21:22:15.640] [error] OpenGL Message: 33356 GL_INVALID_VALUE error generated. Operation is not valid from the core profile.\nSource: API\nType: Error\nSeverity: high\n</code></pre> <p>You get this output in the output window... something something invalid value... thats our first clue.</p> <p>Let's check the callstack. Im using Visual Studio Code here.</p> <p></p> <p>Our program is quite simple at the moment so there is not much to see. But we do see the debugcallback at the top, them entry which goes into the graphics driver, and below the caller issuing the last gl command. Which in this case...</p> <p></p> <p>... sits in the main function at line 269.</p> <p>We get the offending call there. <code>glClear(0xFFF)</code></p> <p></p> <p>What did the error message say again? <code>GL_INVALID_VALUE</code>.</p> <p>What do we do now? Ideally look at the opengl specification to figure out what VALID values glClear can take.</p> <p>OpenGL Specification</p> <p>Find the clear call in there and fix the problem.</p> <p>Then compile and run the program again and see if it fixed the issue.</p>"},{"location":"02-debugging/02-debug-callback-exercise-02/","title":"Exercise 2","text":""},{"location":"02-debugging/02-debug-callback-exercise-02/#debug-callback-exercise-2","title":"Debug Callback Exercise 2","text":"<ul> <li>Go to the debug callback and set a break point at the end of the function</li> <li>Go to the main loop and find the <code>glBindVertexArray(inputLayout);</code> call.</li> <li>Comment it out</li> <li>Compile and run</li> </ul> <p>What do you see?</p> <pre><code>[2023-11-23 23:15:39.879] [error] OpenGL Message: 33356 GL_INVALID_OPERATION error generated. Array object is not active.\nSource: API\nType: Error\nSeverity: high\n</code></pre> <p>Do you remember what I mentioned before that Vertex Array Object is an unfortunate name? It's here again <code>Array object</code>. </p> <p>Anyway, can you make the connection?</p> <p>Its an invalid operation to draw something without having an active input layout (VAO/Vertex Array Object).</p> <p>Solution is to uncomment it. Keep in mind to have at least 1 vao bound. In fact you technically only need one for everything and change the attributes it stands for dynamically as you go.</p> <p>However we will be using an input layout per vertex type where necessary, its easier to keep track of conceptually and mentally, I think.</p>"},{"location":"02-debugging/02-debug-callback/","title":"Debug Callback","text":"<p>The debug callback is a piece of code called by OpenGL in case it disagrees with the values you passed to its functions.</p> <p>Let's hook it up.</p> <p>A free floating function above <code>main</code>.</p> <p>Explain the following blob a bit more</p> <pre><code>void GLAPIENTRY DebugMessageCallback(\n    GLenum source,\n    GLenum type,\n    GLuint id,\n    GLenum severity,\n    [[maybe_unused]] GLsizei length,\n    const GLchar* message,\n    [[maybe_unused]] const void* userParam)\n{\n    // Ignore certain verbose info messages (particularly ones on Nvidia).\n    if (id == 131169 || \n        id == 131185 || // NV: Buffer will use video memory\n        id == 131218 || \n        id == 131204 || // Texture cannot be used for texture mapping\n        id == 131222 ||\n        id == 131154 || // NV: pixel transfer is synchronized with 3D rendering\n        id == 0         // gl{Push, Pop}DebugGroup\n    )\n    return;\n\n    std::stringstream debugMessageStream;\n    debugMessageStream &lt;&lt; message &lt;&lt; '\\n';\n\n    switch (source)\n    {\n        case GL_DEBUG_SOURCE_API: debugMessageStream &lt;&lt; \"Source: API\"; break;\n        case GL_DEBUG_SOURCE_WINDOW_SYSTEM: debugMessageStream &lt;&lt; \"Source: Window Manager\"; break;\n        case GL_DEBUG_SOURCE_SHADER_COMPILER: debugMessageStream &lt;&lt; \"Source: Shader Compiler\"; break;\n        case GL_DEBUG_SOURCE_THIRD_PARTY: debugMessageStream &lt;&lt; \"Source: Third Party\"; break;\n        case GL_DEBUG_SOURCE_APPLICATION: debugMessageStream &lt;&lt; \"Source: Application\"; break;\n        case GL_DEBUG_SOURCE_OTHER: debugMessageStream &lt;&lt; \"Source: Other\"; break;\n    }\n\n    debugMessageStream &lt;&lt; '\\n';\n\n    switch (type)\n    {\n        case GL_DEBUG_TYPE_ERROR: debugMessageStream &lt;&lt; \"Type: Error\"; break;\n        case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: debugMessageStream &lt;&lt; \"Type: Deprecated Behaviour\"; break;\n        case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: debugMessageStream &lt;&lt; \"Type: Undefined Behaviour\"; break;\n        case GL_DEBUG_TYPE_PORTABILITY: debugMessageStream &lt;&lt; \"Type: Portability\"; break;\n        case GL_DEBUG_TYPE_PERFORMANCE: debugMessageStream &lt;&lt; \"Type: Performance\"; break;\n        case GL_DEBUG_TYPE_MARKER: debugMessageStream &lt;&lt; \"Type: Marker\"; break;\n        case GL_DEBUG_TYPE_PUSH_GROUP: debugMessageStream &lt;&lt; \"Type: Push Group\"; break;\n        case GL_DEBUG_TYPE_POP_GROUP: debugMessageStream &lt;&lt; \"Type: Pop Group\"; break;\n        case GL_DEBUG_TYPE_OTHER: debugMessageStream &lt;&lt; \"Type: Other\"; break;\n    }\n\n    debugMessageStream &lt;&lt; '\\n';\n\n    switch (severity)\n    {\n        case GL_DEBUG_SEVERITY_HIGH: debugMessageStream &lt;&lt; \"Severity: high\"; break;\n        case GL_DEBUG_SEVERITY_MEDIUM: debugMessageStream &lt;&lt; \"Severity: medium\"; break;\n        case GL_DEBUG_SEVERITY_LOW: debugMessageStream &lt;&lt; \"Severity: low\"; break;\n        case GL_DEBUG_SEVERITY_NOTIFICATION: debugMessageStream &lt;&lt; \"Severity: notification\"; break;\n    }\n\n    spdlog::error(\"OpenGL Message: {} {}\", type, debugMessageStream.str());\n}\n</code></pre> <p>That alone doesn't do anything. We need to tell <code>OpenGL</code> about it too. After <code>gladLoadGLLoader</code> we add those lines.</p> <pre><code>    glDebugMessageCallback(DebugMessageCallback, nullptr);\n    glEnable(GL_DEBUG_OUTPUT);\n    glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);\n</code></pre> <p><code>glDebugMessageCallback</code> hands over our callback to OpenGL, and the next <code>glEnable</code> call enables the debug callback in general.</p> <p>The next line <code>glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS)</code> is the neat part.</p> <p>If we place a break point in our debug callback, let's say at this line <code>spdlog::error(\"OpenGL Message: ...</code> then we will naturally get a call stack, but we will also get the right callstack and can follow it to the offending glXXX function which OpenGL was not happy about.</p> <p>The output also contains somewhat meaningful output which can tell us what exactly we did wrong, well, its not always perfect in telling us whats the problem, but its 10000% better than what was used before... the dreaded <code>GLCHECK(...)</code> (or <code>GLCALL</code> or whatever else people used to call it) macro, which in most cases called <code>glGetError</code> which didnt provide any meaningful hint about what the problem is.</p> <p>Let's try it out.</p> <p>I have prepared 2 exercises.</p>"},{"location":"02-debugging/03-renderdoc/","title":"RenderDoc","text":"<p>RenderDoc is a very powerful tool which can help us find problems with our code/engine/idea, it's a frame debugger.</p> <p>Most of the time when people start out, first thing which isn't working is the first triangle or the 2nd triangle right after that.</p> <p>They tend to get a black screen and then don't know what to do next or how to fix it.</p> <p>That's where <code>RenderDoc</code> can help.</p> <p>You should get it right away from here and install it.</p> <p>It comes with a useful Getting Started guide which you SHOULD read.</p> <p>Please read it, it takes only a few minutes but explains the basics of how <code>RenderDoc</code> is used.</p>"},{"location":"02-debugging/04-renderdoc-exercise-01/","title":"Exercise 1","text":"<p>Find this line in the <code>Main.cpp</code> of <code>BasicApplicationAndTriangle</code></p> <p><code>glEnableVertexArrayAttrib(inputLayout, 1);</code></p> <p>and comment it out. You should get a black triangle and most likely no further output about that something is \"wrong\".</p> <p>Uncomment it, and compile it again, then take a capture with <code>RenderDoc</code>, so that you have something to compare against.</p> <p>Then comment it out again, compile it again and then take another capture with <code>RenderDoc</code>.</p> <p>Go through the windows and stages in both captures and try to find what is wrong.</p> <p>... Really try to compare the two without reading beyond this line of text ...</p> <p>We purposefully modified something in the input layout (VAO) which is part of which stage of the graphics pipeline?</p> <p>Exactly: <code>Input Assembly</code> (IA). Thats the one were you should look closer.</p> <p></p> <p>You can see the 2nd attribute is not enabled - since we purposefully commented that out - and the rest of the attribute is therefore ignored.</p> <p>You can go check further now how it affects how OpenGL is reading the contents of the vertex buffer, by clicking on that arrow in the \"Go\" column on the far right.</p> <p></p> <p>Can you see it? <code>i_color</code> values are all zero, the vertex shader transports that value further in form of <code>v_color</code> over to the fragment shader and the values of 0.0f stay.</p> <p>Now a color of 0.0f, 0.0f, 0.0f maps to <code>Black</code> and that's exactly what we see here.</p>"},{"location":"02-debugging/05-nsight-graphics/","title":"Nsight Graphics","text":"<p>NVidia's NSight Graphics</p> <p>Another very powerful tool, even more powerful than RenderDoc since it contains more things than just a frame debugger.</p> <p>NSight Graphics</p>"},{"location":"99910-basic-triangle/01-basic-application/","title":"Basic Application","text":"","tags":["GLFW","OpenGL","GLAD"]},{"location":"99910-basic-triangle/01-basic-application/#initial-cmake-setup","title":"Initial CMake setup","text":"<p>If you want to follow from scratch, let me explain how I did it.</p> <p>You pick a folder somewhere on your drives. Let's call the folder <code>~/Projects/OpenGLGettingStarted</code> (on Linux) or <code>C:\\Users\\YourUserName\\Documents\\Projects\\OpenGLGettingStarted</code> (on Windows).</p> <p>Create a folder/file structure like this. Leave Application.{hpp/cpp} empty for now, I will explain in a minute what we do there. <pre><code>OpenGLGettingStarted\n\u251c\u2500\u2500 lib\n\u2502   \u2514\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 Shared\n\u2502   \u2502   \u251c\u2500\u2500 Application.cpp\n\u2502   \u2502   \u251c\u2500\u2500 Application.hpp\n\u2502   \u2502   \u2514\u2500\u2500 CMakeLists.txt\n\u2514\u2500\u2500 CMakeLists.txt\n</code></pre></p> <p>So, <code>OpenGLGettingStarted/CMakeLists.txt</code> is our main project file - you could compare it to <code>Visual Studio</code>s solution file, if you worked with <code>VS</code> before. This one should look like this</p> OpenGLGettingStarted/CMakeLists.txt<pre><code>project(OpenGLGettingStarted)\n\nset(CMAKE_CXX_STANDARD 23)\n\nadd_subdirectory(lib)\nadd_subdirectory(src/01-01-BasicWindow)\n</code></pre> <p>Then we will need <code>OpenGLGettingStarted/lib/CMakeLists.txt</code> which has a bit more content since we need to load a bunch of dependencies, as mentioned above, <code>GLFW</code>, <code>GLAD</code> and so forth</p> OpenGLGettingStarted/lib/CMakeLists.txt<pre><code># Dependencies\n\ninclude(FetchContent)\n\nfind_package(OpenGL REQUIRED)\n\n#- GLFW ---------------------------------------------------------------------\n\nFetchContent_Declare(\n    glfw\n    GIT_REPOSITORY https://github.com/glfw/glfw\n    GIT_TAG        3.3.8\n    GIT_SHALLOW    TRUE\n    GIT_PROGRESS   TRUE\n)\nmessage(\"Fetching glfw\")\nset(GLFW_BUILD_TESTS OFF CACHE BOOL \"\")\nset(GLFW_BUILD_DOCS OFF CACHE BOOL \"\")\nset(GLFW_INSTALL OFF CACHE BOOL \"\")\nset(GLFW_BUILD_EXAMPLES OFF CACHE BOOL \"\")\nFetchContent_MakeAvailable(glfw)\n\n#- GLAD ---------------------------------------------------------------------\n\nFetchContent_Declare(\n    glad\n    GIT_REPOSITORY https://github.com/Dav1dde/glad.git\n    GIT_SHALLOW    TRUE\n    GIT_PROGRESS   TRUE\n)\n\nFetchContent_GetProperties(glad)\nif(NOT glad_POPULATED)\n    message(\"Fetching glad\")\n    FetchContent_Populate(glad)\n    set(GLAD_PROFILE \"core\" CACHE STRING \"OpenGL profile\")\n    set(GLAD_API \"gl=4.6\" CACHE STRING \"API type/version pairs, like \\\"gl=4.6\\\", no version means latest\")\n    set(GLAD_GENERATOR \"c\" CACHE STRING \"Language to generate the binding for\")\n    set(GLAD_EXTENSIONS \"GL_ARB_bindless_texture\" CACHE STRING \"Extensions to take into consideration when generating the bindings\")\n    add_subdirectory(${glad_SOURCE_DIR} ${glad_BINARY_DIR})\nendif()\n\n#- SPDLOG ---------------------------------------------------------------------\n\nFetchContent_Declare(\n    spdlog\n    GIT_REPOSITORY https://github.com/gabime/spdlog.git\n    GIT_TAG        v1.10.0\n    GIT_SHALLOW    TRUE\n    GIT_PROGRESS   TRUE\n)\n\nmessage(\"Fetching spdlog\")\nFetchContent_MakeAvailable(spdlog)\n\n#- GLM ---------------------------------------------------------------------\n\nFetchContent_Declare(\n    glm\n    GIT_REPOSITORY https://github.com/g-truc/glm\n    GIT_TAG        master\n    GIT_SHALLOW    TRUE\n    GIT_PROGRESS   TRUE\n)\n\nmessage(\"Fetching glm\")\nFetchContent_MakeAvailable(glm)\ntarget_compile_definitions(glm INTERFACE GLM_FORCE_SILENT_WARNINGS)\n\n#- DEAR IMGUI---------------------------------------------------------------------\n\nFetchContent_Declare(\n    imgui\n    GIT_REPOSITORY https://github.com/ocornut/imgui\n    GIT_TAG        v1.88\n    GIT_SHALLOW    TRUE\n    GIT_PROGRESS   TRUE\n)\n\nFetchContent_GetProperties(imgui)\nif(NOT imgui_POPULATED)\n    message(\"Fetching imgui\")\n    FetchContent_Populate(imgui)\n\n    add_library(imgui\n        ${imgui_SOURCE_DIR}/imgui.cpp\n        ${imgui_SOURCE_DIR}/imgui_demo.cpp\n        ${imgui_SOURCE_DIR}/imgui_draw.cpp\n        ${imgui_SOURCE_DIR}/imgui_widgets.cpp\n        ${imgui_SOURCE_DIR}/imgui_tables.cpp\n        ${imgui_SOURCE_DIR}/backends/imgui_impl_opengl3.cpp\n        ${imgui_SOURCE_DIR}/backends/imgui_impl_glfw.cpp)\n\n    target_include_directories(imgui PUBLIC\n        ${imgui_SOURCE_DIR}\n        ${imgui_SOURCE_DIR}/backends\n        ${glfw_SOURCE_DIR}/include)\n\n    target_link_libraries(imgui PRIVATE glfw)\nendif ()\n\n#- TRACY ---------------------------------------------------------------------\n\nFetchContent_Declare(\n    tracy\n    GIT_REPOSITORY  https://github.com/wolfpld/tracy.git\n    GIT_TAG         master\n    GIT_SHALLOW     TRUE\n    GIT_PROGRESS    TRUE\n)\n\nmessage(\"Fetching tracy\")\nset(TRACY_ENABLE ON CACHE BOOL \"Enable profiling\")\n#set(TRACY_NO_SYSTEM_TRACING ON CACHE BOOL \"Disable System Tracing\")\nset(TRACY_ONLY_IPV4 ON CACHE BOOL \"\" FORCE)\nset(TRACY_ONLY_LOCALHOST ON CACHE BOOL \"\" FORCE)\nset(TRACY_NO_FRAME_IMAGE ON CACHE BOOL \"\" FORCE)\nFetchContent_MakeAvailable(tracy)\n\n#- DEBUGBREAK ---------------------------------------------------------------------\n\nFetchContent_Declare(\n    debugbreak\n    GIT_REPOSITORY https://github.com/scottt/debugbreak\n    GIT_SHALLOW    TRUE\n    GIT_PROGRESS   TRUE\n)\n\nFetchContent_GetProperties(debugbreak)\nif(NOT debugbreak_POPULATED)\n    message(\"Fetching debugbreak\")\n    FetchContent_Populate(debugbreak)\n\n    add_library(debugbreak INTERFACE ${debugbreak_SOURCE_DIR}/debugbreak.h)\n    target_include_directories(debugbreak INTERFACE ${debugbreak_SOURCE_DIR})\nendif()\n\n#- STB ---------------------------------------------------------------------\n\nFetchContent_Declare(\n    stb_image\n    GIT_REPOSITORY  https://github.com/nothings/stb.git\n    GIT_TAG         master\n    GIT_SHALLOW     TRUE\n    GIT_PROGRESS    TRUE\n)\nFetchContent_GetProperties(stb_image)\nif(NOT stb_image_POPULATED)\n    FetchContent_Populate(stb_image)\n    message(\"Fetching stb_image\")\n\n    add_library(stb_image INTERFACE ${stb_image_SOURCE_DIR}/stb_image.h)\n    target_include_directories(stb_image INTERFACE ${stb_image_SOURCE_DIR})\nendif()\n</code></pre> <p>FetchContent will clone the repos according to what was specified and some options are set for one or another library, like Tracy to enable tracing, or for glad to provide bindings for OpenGL 4.6</p> <p>As mentioned earlier I would like to use a base class <code>Application</code> which handles input and windowing things, as well as provides a ready to use opengl context for us to use.</p> <p>That means we create a <code>src</code> folder and within a <code>Shared</code> folder where we will create those two files <code>Application.hpp</code> and <code>Application.cpp</code></p> <p><code>Shared</code> is turned into a target which we can link with all future applications to provide Application-functionality to all of them, for that we need yet another <code>CMakeLists.txt</code>. Which will look like that</p> OpenGLGettingStarted/src/Shared/CMakeLists.txt<pre><code>add_library(Shared\n    Application.cpp\n)\n\ntarget_link_libraries(Shared PRIVATE glfw glad spdlog debugbreak)\n</code></pre> <p>As you can see it creates a library, and needs <code>Application.cpp</code> and it depends on glfw, glad, spdlog and debugbreak. If we have, for some reason, more things we would like to share across all other applications/examples later on, perhaps some Input class of some sort, then it would go in there too as <code>Input.cpp</code> to be compiled into the shared library.</p> <p>That applies to the other <code>CMakeLists.txt</code> too by the way. When we add new .cpp files to the project they should be added to the target. <code>Visual Studio</code> and <code>Clion</code> (since they support CMake out of the box) might add .cpp files automatically for you.</p> <p>Ok then two things are missing. Bear with me its a little bit of code incoming :)</p> OpenGLGettingStarted/src/Shared/Application.hpp<pre><code>#pragma once\n\n#include &lt;cstdint&gt;\n#include &lt;string_view&gt;\n#include &lt;expected&gt;\n\nstruct GLFWwindow;\n\nclass Application\n{\npublic:\n    virtual ~Application();\n\n    void Run();\n\nprotected:\n    static std::expected&lt;std::string, std::string&gt; ReadTextFromFile(std::string_view filePath);\n\n    virtual bool Initialize();\n    virtual bool Load();\n    virtual void Unload();\n\n    virtual void Update();\n    virtual void Render();\n\n    virtual void OnFramebufferResized();\n    virtual void OnKeyDown(\n        int32_t key,\n        int32_t modifiers,\n        int32_t scancode);\n    virtual void OnKeyUp(\n        int32_t key,\n        int32_t modifiers,\n        int32_t scancode);\n\n    virtual void OnOpenGLDebugMessage(uint32_t messageType, std::string_view debugMessage);\n\n    int32_t framebufferWidth = 0;\n    int32_t framebufferHeight = 0;    \n\nprivate:\n    friend class ApplicationAccess;\n\n    GLFWwindow* _windowHandle = nullptr;\n    bool _isFullscreen = false;\n\n    void ToggleFullscreen();\n};\n</code></pre> <p>We said we wanted to make an Application base class which will handle windowing and input for us, and perhaps the odd other thing too.</p> <code>Run</code> <p>Thats our only gate to the outside, thats what <code>main</code> will call in our actual examples later on</p> <code>ReadTextFromFile</code> <p>This reads text from a file</p> OpenGLGettingStarted/src/Shared/Application.cpp<pre><code>std::expected&lt;std::string, std::string&gt; Application::ReadTextFromFile(std::string_view filePath)\n{\n    std::ifstream file(filePath.data(), std::ios::ate);\n    if (file.bad())\n    {\n        return std::unexpected(std::format(\"Io: Unable to read from file {}\", filePath));\n    }\n    auto fileSize = file.tellg();\n    if (fileSize == 0)\n    {\n        return std::unexpected(std::format(\"Io: File {} is empty\", filePath));\n    }\n\n    std::string result(fileSize, '\\0');\n    file.seekg(0);\n    file.read((char*)result.data(), result.size());\n    return result;\n}\n</code></pre> <code>Initialize</code> <p>thats the method where we initialize application relevant things like, creating the main window, adjusting it to be in center, hooking up callbacks, since we use glfw and asking for an OpenGL context</p> OpenGLGettingStarted/src/Shared/Application.cpp<pre><code>bool Application::Initialize()\n{\n    if (glfwInit() == GLFW_FALSE)\n    {\n        spdlog::error(\"Glfw: Unable to initialize\");\n        return false;\n    }\n\n    glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_API);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\n    glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE);\n    glfwWindowHint(GLFW_DECORATED, GLFW_TRUE);\n    glfwWindowHint(GLFW_SCALE_TO_MONITOR, GLFW_TRUE);\n\n    auto primaryMonitor = glfwGetPrimaryMonitor();\n    auto videoMode = glfwGetVideoMode(primaryMonitor);\n\n    auto screenWidth = videoMode-&gt;width;\n    auto screenHeight = videoMode-&gt;height;\n\n    auto windowWidth = static_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(screenWidth) * 0.8f);\n    auto windowHeight = static_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(screenHeight) * 0.8f);\n\n    _windowHandle = glfwCreateWindow(windowWidth, windowHeight, \"OpenGL - Getting Started\", nullptr, nullptr);\n    if (_windowHandle == nullptr)\n    {\n        const char* errorDescription = nullptr;\n        auto errorCode = glfwGetError(&amp;errorDescription);\n        if (errorCode != GLFW_NO_ERROR)\n        {\n            spdlog::error(\"GLFW: Unable to create window Details_{}\", errorDescription);\n        }\n        return false;\n    }\n\n    glfwSetWindowUserPointer(_windowHandle, this);\n\n    int32_t monitorLeft = 0;\n    int32_t monitorTop = 0;\n    glfwGetMonitorPos(primaryMonitor, &amp;monitorLeft, &amp;monitorTop);\n    glfwSetWindowPos(_windowHandle, screenWidth / 2 - windowWidth / 2 + monitorLeft, screenHeight / 2 - windowHeight / 2 + monitorTop);\n\n    glfwSetFramebufferSizeCallback(_windowHandle, ApplicationAccess::FramebufferResizeCallback);\n    glfwSetKeyCallback(_windowHandle, ApplicationAccess::KeyCallback);\n\n    glfwMakeContextCurrent(_windowHandle);\n    gladLoadGLLoader((GLADloadproc)glfwGetProcAddress);\n\n    glDebugMessageCallback(ApplicationAccess::DebugMessageCallback, _windowHandle);\n    glEnable(GL_DEBUG_OUTPUT);\n    glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);\n\n    glEnable(GL_FRAMEBUFFER_SRGB);\n    glEnable(GL_CULL_FACE);\n    glCullFace(GL_BACK);\n    glFrontFace(GL_CCW);\n\n    glClearColor(0.35f, 0.76f, 0.16f, 1.0f);\n    glClearDepthf(1.0f);\n\n    return true;\n}\n</code></pre> <code>Load</code> <p>Thats empty in here for now, but this one is supposed to be called after <code>Initialize</code> and you would typically do things like loading programs, loading textures or levels before rendering anything</p> OpenGLGettingStarted/src/Shared/Application.cpp<pre><code>bool Application::Load()\n{\n    return true;\n}\n</code></pre> <code>Unload</code> <p>All the resources we loaded in <code>Load</code> should be unloaded too at some point, that's what <code>Unload</code> is there for. Many people rely on the operating system to clean up after the program has shut down, I don't.</p> OpenGLGettingStarted/src/Shared/Application.cpp<pre><code>void Application::Unload()\n{\n    if (_windowHandle != nullptr)\n    {\n        glfwDestroyWindow(_windowHandle);\n    }\n\n    glfwTerminate();\n}\n</code></pre> <code>Update</code> <p>Is supposed to be for your game/business logic, where you update physics, ask the network for new state or prepare state for the gpu to render, like preparing a matrix buffer which contains all transforms of your world objects</p> OpenGLGettingStarted/src/Shared/Application.cpp<pre><code>void Application::Update()\n{\n}\n</code></pre> <code>Render</code> <p>Here goes all the render code, mostly draw calls</p> OpenGLGettingStarted/src/Shared/Application.cpp<pre><code>void Application::Render()\n{\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n}\n</code></pre> <code>OnFramebufferResized</code> <p>When you resize the window, be it dragging a corner to increase/decrease the window size, When the window size is changed, its non-client-rectangle area (the window part which isnt the border or system menu/window title bar). <code>GLFW</code> detects that and calls our function (<code>ApplicationAccess::FramebufferResizeCallback</code>) which will check for valid values   and calls this method. In this method we can then safely assume the window has been resized to proper values and we can do whatever we like in here. </p> OpenGLGettingStarted/src/Shared/Application.cpp<pre><code>void Application::OnFramebufferResized()\n{\n    spdlog::info(\"Framebuffer resized to {}_{}\", framebufferWidth, framebufferHeight);\n\n    glViewport(0, 0, framebufferWidth, framebufferHeight);\n}\n</code></pre> <code>OnKeyDown</code> should be self explanatory OpenGLGettingStarted/src/Shared/Application.cpp<pre><code>void Application::OnKeyDown(\n    int32_t key,\n    int32_t modifiers,\n    int32_t scancode)\n{\n    if (key == GLFW_KEY_ESCAPE)\n    {\n        glfwSetWindowShouldClose(_windowHandle, GLFW_TRUE);\n    }\n\n    if (key == GLFW_KEY_F11)\n    {\n        ToggleFullscreen();\n    }\n}\n</code></pre> <code>OnKeyUp</code> should be self explanatory OpenGLGettingStarted/src/Shared/Application.cpp<pre><code>void Application::OnKeyUp(\n    int32_t key,\n    int32_t modifiers,\n    int32_t scancode)\n{\n}\n</code></pre> <code>OnOpenGLDebugMessage</code> <p>OpenGL has this neat mechanism which is called <code>debug message callback</code>, where it will report a message when some state doesnt make sense for OpenGL and we can react to that. In our case, we will use that to halt the debugger (hence debugbreak is used) so that we are able to follow the call stack to see who the offending opengl call is causing trouble - which in most cases isnt OpenGL's fault but yours :) because you passed a wrong value to a glXXX call. We will see that later on</p> <code>ToggleFullsceen</code> <p>As the name suggests, it goggles the window to/from fullscreen/windowed</p> <p>There is also this <code>ApplicationAccess</code> thing. That only exists in <code>Application.cpp</code> which we will see next and I will explain there what is is.</p> OpenGLGettingStarted/src/Shared/Application.cpp<pre><code>#include \"Application.hpp\"\n\n#include &lt;glad/glad.h&gt;\n#include &lt;GLFW/glfw3.h&gt;\n#include &lt;spdlog/spdlog.h&gt;\n\n#include &lt;debugbreak.h&gt;\n\n#include &lt;format&gt;\n#include &lt;fstream&gt;\n\nclass ApplicationAccess final\n{\npublic:\n    static void FramebufferResizeCallback(\n        GLFWwindow* window,\n        int32_t framebufferWidth,\n        int32_t framebufferHeight)\n    {\n        auto application = static_cast&lt;Application*&gt;(glfwGetWindowUserPointer(window));\n        if (application == nullptr)\n        {\n            spdlog::error(\"App: You forgot to call glfwSetWindowUserPointer in Application::Initialize\");\n            return;\n        }\n\n        if (framebufferWidth &gt; 0 &amp;&amp; framebufferHeight &gt; 0)\n        {\n            application-&gt;framebufferWidth = framebufferWidth;\n            application-&gt;framebufferHeight = framebufferHeight;\n            application-&gt;OnFramebufferResized();\n            application-&gt;Render();\n        }\n    }\n\n    static void KeyCallback(\n        GLFWwindow* window,\n        int32_t key,\n        int32_t scancode,\n        int32_t action,\n        int32_t modifiers\n    )\n    {\n        auto application = static_cast&lt;Application*&gt;(glfwGetWindowUserPointer(window));\n        if (application == nullptr)\n        {\n            spdlog::error(\"App: You forgot to call glfwSetWindowUserPointer in Application::Initialize\");\n            return;\n        }\n\n        if (action == GLFW_PRESS || action == GLFW_REPEAT)\n        {\n            application-&gt;OnKeyDown(key, modifiers, scancode);\n        }\n        else\n        {\n            application-&gt;OnKeyUp(key, modifiers, scancode);\n        }\n    }\n\n    static void GLAPIENTRY DebugMessageCallback(GLenum source,\n                                        GLenum type,\n                                        GLuint id,\n                                        GLenum severity,\n                                        [[maybe_unused]] GLsizei length,\n                                        const GLchar* message,\n                                        [[maybe_unused]] const void* userParam)\n    {\n        // Ignore certain verbose info messages (particularly ones on Nvidia).\n        if (id == 131169 || \n            id == 131185 || // NV: Buffer will use video memory\n            id == 131218 || \n            id == 131204 || // Texture cannot be used for texture mapping\n            id == 131222 ||\n            id == 131154 || // NV: pixel transfer is synchronized with 3D rendering\n            id == 0         // gl{Push, Pop}DebugGroup\n        )\n        return;\n\n        std::stringstream debugMessageStream;\n        debugMessageStream &lt;&lt; message &lt;&lt; '\\n';\n\n        switch (source)\n        {\n            case GL_DEBUG_SOURCE_API: debugMessageStream &lt;&lt; \"Source: API\"; break;\n            case GL_DEBUG_SOURCE_WINDOW_SYSTEM: debugMessageStream &lt;&lt; \"Source: Window Manager\"; break;\n            case GL_DEBUG_SOURCE_SHADER_COMPILER: debugMessageStream &lt;&lt; \"Source: Shader Compiler\"; break;\n            case GL_DEBUG_SOURCE_THIRD_PARTY: debugMessageStream &lt;&lt; \"Source: Third Party\"; break;\n            case GL_DEBUG_SOURCE_APPLICATION: debugMessageStream &lt;&lt; \"Source: Application\"; break;\n            case GL_DEBUG_SOURCE_OTHER: debugMessageStream &lt;&lt; \"Source: Other\"; break;\n        }\n\n        debugMessageStream &lt;&lt; '\\n';\n\n        switch (type)\n        {\n            case GL_DEBUG_TYPE_ERROR: debugMessageStream &lt;&lt; \"Type: Error\"; break;\n            case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: debugMessageStream &lt;&lt; \"Type: Deprecated Behaviour\"; break;\n            case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: debugMessageStream &lt;&lt; \"Type: Undefined Behaviour\"; break;\n            case GL_DEBUG_TYPE_PORTABILITY: debugMessageStream &lt;&lt; \"Type: Portability\"; break;\n            case GL_DEBUG_TYPE_PERFORMANCE: debugMessageStream &lt;&lt; \"Type: Performance\"; break;\n            case GL_DEBUG_TYPE_MARKER: debugMessageStream &lt;&lt; \"Type: Marker\"; break;\n            case GL_DEBUG_TYPE_PUSH_GROUP: debugMessageStream &lt;&lt; \"Type: Push Group\"; break;\n            case GL_DEBUG_TYPE_POP_GROUP: debugMessageStream &lt;&lt; \"Type: Pop Group\"; break;\n            case GL_DEBUG_TYPE_OTHER: debugMessageStream &lt;&lt; \"Type: Other\"; break;\n        }\n\n        debugMessageStream &lt;&lt; '\\n';\n\n        switch (severity)\n        {\n            case GL_DEBUG_SEVERITY_HIGH: debugMessageStream &lt;&lt; \"Severity: high\"; break;\n            case GL_DEBUG_SEVERITY_MEDIUM: debugMessageStream &lt;&lt; \"Severity: medium\"; break;\n            case GL_DEBUG_SEVERITY_LOW: debugMessageStream &lt;&lt; \"Severity: low\"; break;\n            case GL_DEBUG_SEVERITY_NOTIFICATION: debugMessageStream &lt;&lt; \"Severity: notification\"; break;\n        }\n\n        if (userParam != nullptr)\n        {\n            auto windowHandle = (GLFWwindow*)userParam;\n            auto application = static_cast&lt;Application*&gt;(glfwGetWindowUserPointer(windowHandle));\n            if (application == nullptr)\n            {\n                spdlog::error(\"App: You forgot to call glfwSetWindowUserPointer in Application::Initialize\");\n                return;\n            }\n\n            application-&gt;OnOpenGLDebugMessage(type, debugMessageStream.str());\n        }\n    }\n};\n\nApplication::~Application()\n{\n\n}\n\nstd::expected&lt;std::string, std::string&gt; Application::ReadTextFromFile(std::string_view filePath)\n{\n    std::ifstream file(filePath.data(), std::ios::ate);\n    if (file.bad())\n    {\n        return std::unexpected(std::format(\"Io: Unable to read from file {}\", filePath));\n    }\n    auto fileSize = file.tellg();\n    if (fileSize == 0)\n    {\n        return std::unexpected(std::format(\"Io: File {} is empty\", filePath));\n    }\n\n    std::string result(fileSize, '\\0');\n    file.seekg(0);\n    file.read((char*)result.data(), result.size());\n    return result;\n}\n\nvoid Application::Run()\n{\n    if (!Initialize())\n    {\n        return;\n    }\n\n    spdlog::info(\"App: Initialized\");\n\n    if (!Load())\n    {\n        return;\n    }\n\n    spdlog::info(\"App: Loaded\");\n\n    while (!glfwWindowShouldClose(_windowHandle))\n    {\n        glfwPollEvents();\n\n        Update();\n\n        Render();\n\n        glfwSwapBuffers(_windowHandle);\n    }\n\n    spdlog::info(\"App: Unloading\");\n\n    Unload();\n\n    spdlog::info(\"App: Unloaded\");\n}\n\nbool Application::Initialize()\n{\n    if (glfwInit() == GLFW_FALSE)\n    {\n        spdlog::error(\"Glfw: Unable to initialize\");\n        return false;\n    }\n\n    glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_API);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\n    glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE);\n    glfwWindowHint(GLFW_DECORATED, GLFW_TRUE);\n    glfwWindowHint(GLFW_SCALE_TO_MONITOR, GLFW_TRUE);\n\n    auto primaryMonitor = glfwGetPrimaryMonitor();\n    auto videoMode = glfwGetVideoMode(primaryMonitor);\n\n    auto screenWidth = videoMode-&gt;width;\n    auto screenHeight = videoMode-&gt;height;\n\n    auto windowWidth = static_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(screenWidth) * 0.8f);\n    auto windowHeight = static_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(screenHeight) * 0.8f);\n\n    _windowHandle = glfwCreateWindow(windowWidth, windowHeight, \"OpenGL - Getting Started\", nullptr, nullptr);\n    if (_windowHandle == nullptr)\n    {\n        const char* errorDescription = nullptr;\n        auto errorCode = glfwGetError(&amp;errorDescription);\n        if (errorCode != GLFW_NO_ERROR)\n        {\n            spdlog::error(\"GLFW: Unable to create window Details_{}\", errorDescription);\n        }\n        return false;\n    }\n\n    glfwSetWindowUserPointer(_windowHandle, this);\n\n    int32_t monitorLeft = 0;\n    int32_t monitorTop = 0;\n    glfwGetMonitorPos(primaryMonitor, &amp;monitorLeft, &amp;monitorTop);\n    glfwSetWindowPos(_windowHandle, screenWidth / 2 - windowWidth / 2 + monitorLeft, screenHeight / 2 - windowHeight / 2 + monitorTop);\n\n    glfwSetFramebufferSizeCallback(_windowHandle, ApplicationAccess::FramebufferResizeCallback);\n    glfwSetKeyCallback(_windowHandle, ApplicationAccess::KeyCallback);\n\n    glfwMakeContextCurrent(_windowHandle);\n    gladLoadGLLoader((GLADloadproc)glfwGetProcAddress);\n\n    glDebugMessageCallback(ApplicationAccess::DebugMessageCallback, _windowHandle);\n    glEnable(GL_DEBUG_OUTPUT);\n    glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);\n\n    glEnable(GL_FRAMEBUFFER_SRGB);\n    glEnable(GL_CULL_FACE);\n    glCullFace(GL_BACK);\n    glFrontFace(GL_CCW);\n\n    glClearColor(0.35f, 0.76f, 0.16f, 1.0f);\n    glClearDepthf(1.0f);\n\n    return true;\n}\n\nbool Application::Load()\n{\n    return true;\n}\n\nvoid Application::Unload()\n{\n    if (_windowHandle != nullptr)\n    {\n        glfwDestroyWindow(_windowHandle);\n    }\n\n    glfwTerminate();\n}\n\nvoid Application::Update()\n{\n}\n\nvoid Application::Render()\n{\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n}\n\nvoid Application::OnFramebufferResized()\n{\n    spdlog::info(\"Framebuffer resized to {}_{}\", framebufferWidth, framebufferHeight);\n\n    glViewport(0, 0, framebufferWidth, framebufferHeight);\n}\n\nvoid Application::OnKeyDown(\n    int32_t key,\n    int32_t modifiers,\n    int32_t scancode)\n{\n    if (key == GLFW_KEY_ESCAPE)\n    {\n        glfwSetWindowShouldClose(_windowHandle, GLFW_TRUE);\n    }\n\n    if (key == GLFW_KEY_F11)\n    {\n        ToggleFullscreen();\n    }\n}\n\nvoid Application::OnKeyUp(\n    int32_t key,\n    int32_t modifiers,\n    int32_t scancode)\n{\n}\n\nvoid Application::OnOpenGLDebugMessage(uint32_t messageType, std::string_view debugMessage)\n{\n    spdlog::error(debugMessage);\n    if (messageType == GL_DEBUG_TYPE_ERROR)\n    {\n        debug_break();\n    }\n}\n\nvoid Application::ToggleFullscreen()\n{\n    _isFullscreen = !_isFullscreen;\n\n    glfwSetWindowAttrib(_windowHandle, GLFW_DECORATED, _isFullscreen ? GLFW_FALSE : GLFW_TRUE);\n    glfwSetWindowAttrib(_windowHandle, GLFW_RESIZABLE, _isFullscreen ? GLFW_FALSE : GLFW_TRUE);\n\n    int32_t monitorLeft = 0;\n    int32_t monitorTop = 0;\n    auto primaryMonitor = glfwGetPrimaryMonitor();\n    auto videoMode = glfwGetVideoMode(primaryMonitor);\n\n    auto screenWidth = videoMode-&gt;width;\n    auto screenHeight = videoMode-&gt;height;\n\n    glfwGetMonitorPos(primaryMonitor, &amp;monitorLeft, &amp;monitorTop);\n\n    if (_isFullscreen)\n    {\n        glfwSetWindowPos(_windowHandle, monitorLeft, monitorTop);\n        glfwSetWindowSize(_windowHandle, screenWidth, screenHeight);\n    }\n    else\n    {\n        auto windowWidth = static_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(screenWidth) * 0.8f);\n        auto windowHeight = static_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(screenHeight) * 0.8f);\n\n        glfwSetWindowPos(_windowHandle, screenWidth / 2 - windowWidth / 2 + monitorLeft, screenHeight / 2 - windowHeight / 2 + monitorTop);\n        glfwSetWindowSize(_windowHandle, windowWidth, windowHeight);\n    }\n\n    Render();\n}\n</code></pre> <p>TODO</p> <p>Elaborate a bit more on all the methods in Application.cpp</p> <p>TODO</p> <p>Explain OpenGL context + glad</p> <p>TODO</p> <p>Explain the first glXXX calls</p> <p>TODO</p> <p>Explain glDebugMessageCallback a bit more + the big thing i use there as the callback</p>","tags":["GLFW","OpenGL","GLAD"]},{"location":"99910-basic-triangle/01-basic-application/#hellowindowapplication","title":"HelloWindowApplication","text":"<p>Now is the time to create an actual project.</p> <p>Let's call the target HelloWindow and lets put it in <code>src/01-HelloWindow</code>.</p> <p>We need</p> src/01-HelloWindow/HelloWindowApplication.hpp<pre><code>#pragma once\n\n#include \"../Shared/Application.hpp\"\n\nclass HelloWindowApplication final : public Application\n{\nprotected:\n    void Update() override;\n};\n</code></pre> <p>and</p> src/01-HelloWindow/HelloWindowApplication.cpp<pre><code>#include \"HelloWindowApplication.hpp\"\n\n#include &lt;spdlog/spdlog.h&gt;\n\nvoid HelloWindowApplication::Update()\n{\n    Application::Update();\n    spdlog::info(\"Hello from HelloWindowApplication\");\n}\n</code></pre> <p>and also</p> src/01-HelloWindow/Main.cpp<pre><code>#include \"HelloWindowApplication.hpp\"\n\nint32_t main(\n    [[maybe_unused]] int32_t argc,\n    [[maybe_unused]] char* argv[])\n{\n    HelloWindowApplication application;\n    application.Run();\n    return 0;\n}\n</code></pre> <p>All that should compile, but doesn't do anything yet, obviously.</p> <p>Attention. Attention</p> <p>From here onwards is subject to change and under construction. Ignore please :)</p> <p>The important bits here are, initialize <code>GLFW</code>, grab the screen resolution of the current primary monitor so that we can center the window on that primary screen and also resize it to be 80% of the resolution. I really hate windows spawning at random locations everytime you start the application.</p> <p>We also need an active render context, and to load all the relevant opengl functions for that active context we use <code>GLAD</code>.</p> <p>To see we hooked up everything correct so far, we should see a window and its content is a nice frog green.</p> <p>You might wonder wtf that <code>ApplicationAccess</code> class is. It's just a tool to be able to hook into glfw's callbacks and at the same time keep the visibility of the handling functions still within <code>Application</code>. Otherwise those callbacks would need to be public static within <code>Application</code> and thats another thing I dont want, expose things to the public which is not supposed to be public, anyway, fight me if you want.</p> <pre><code>class ApplicationAccess final\n{\npublic:\n    static void FramebufferResizeCallback(\n        GLFWwindow* window,\n        int32_t framebufferWidth,\n        int32_t framebufferHeight)\n    {\n        auto application = static_cast&lt;Application*&gt;(glfwGetWindowUserPointer(window));\n        if (application == nullptr)\n        {\n            spdlog::error(\"App: You forgot to call glfwSetWindowUserPointer in Application::Initialize\");\n            return;\n        }\n\n        if (framebufferWidth &gt; 0 &amp;&amp; framebufferHeight &gt; 0)\n        {\n            application-&gt;framebufferWidth = framebufferWidth;\n            application-&gt;framebufferHeight = framebufferHeight;\n            application-&gt;OnFramebufferResized();\n            application-&gt;Render();\n        }\n    }\n\n    static void KeyCallback(\n        GLFWwindow* window,\n        int32_t key,\n        int32_t scancode,\n        int32_t action,\n        int32_t modifiers\n    )\n    {\n        auto application = static_cast&lt;Application*&gt;(glfwGetWindowUserPointer(window));\n        if (application == nullptr)\n        {\n            spdlog::error(\"App: You forgot to call glfwSetWindowUserPointer in Application::Initialize\");\n            return;\n        }\n\n        if (action == GLFW_PRESS || action == GLFW_REPEAT)\n        {\n            application-&gt;OnKeyDown(key, modifiers, scancode);\n        }\n        else\n        {\n            application-&gt;OnKeyUp(key, modifiers, scancode);\n        }\n    }\n};\n</code></pre> <p>That's <code>ApplicationAccess</code>' implementation. It should be defined above <code>Application</code> class within <code>Application.cpp</code>.</p> <p>You could probably redirect the key information to some other construct, some <code>InputHandler</code> of some kind, rather than having 2 methods in the <code>Application</code> class, but perhaps its an exercise for you to exercise if you want.</p> <p>I'm saying this because many people prefer not to have to access the <code>Application</code> class when they want to check for keypresses in their <code>CameraController</code> :)</p> <p>Ok, moving on, the rest of <code>Application</code>.</p> <pre><code>bool Application::Load()\n{\n    return true;\n}\n\nvoid Application::Unload()\n{\n    if (_windowHandle != nullptr)\n    {\n        glfwDestroyWindow(_windowHandle);\n    }\n\n    glfwTerminate();\n}\n\nvoid Application::Update()\n{\n}\n\nvoid Application::Render()\n{\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n}\n\nvoid Application::OnFramebufferResized()\n{\n    spdlog::info(\"Framebuffer resized to {}_{}\", framebufferWidth, framebufferHeight);\n\n    glViewport(0, 0, framebufferWidth, framebufferHeight);\n}\n\nvoid Application::OnKeyDown(\n    int32_t key,\n    int32_t modifiers,\n    int32_t scancode)\n{\n    if (key == GLFW_KEY_ESCAPE)\n    {\n        glfwSetWindowShouldClose(_windowHandle, GLFW_TRUE);\n    }\n\n    if (key == GLFW_KEY_F11)\n    {\n        ToggleFullscreen();\n    }\n}\n\nvoid Application::OnKeyUp(\n    int32_t key,\n    int32_t modifiers,\n    int32_t scancode)\n{\n}\n\nvoid Application::ToggleFullscreen()\n{\n    _isFullscreen = !_isFullscreen;\n\n    glfwSetWindowAttrib(_windowHandle, GLFW_DECORATED, _isFullscreen ? GLFW_FALSE : GLFW_TRUE);\n    glfwSetWindowAttrib(_windowHandle, GLFW_RESIZABLE, _isFullscreen ? GLFW_FALSE : GLFW_TRUE);\n\n    int32_t monitorLeft = 0;\n    int32_t monitorTop = 0;\n    auto primaryMonitor = glfwGetPrimaryMonitor();\n    auto videoMode = glfwGetVideoMode(primaryMonitor);\n\n    auto screenWidth = videoMode-&gt;width;\n    auto screenHeight = videoMode-&gt;height;\n\n    glfwGetMonitorPos(primaryMonitor, &amp;monitorLeft, &amp;monitorTop);\n\n    if (_isFullscreen)\n    {\n        glfwSetWindowPos(_windowHandle, monitorLeft, monitorTop);\n        glfwSetWindowSize(_windowHandle, screenWidth, screenHeight);\n    }\n    else\n    {\n        auto windowWidth = static_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(screenWidth) * 0.8f);\n        auto windowHeight = static_cast&lt;int32_t&gt;(static_cast&lt;float&gt;(screenHeight) * 0.8f);\n\n        glfwSetWindowPos(_windowHandle, screenWidth / 2 - windowWidth / 2 + monitorLeft, screenHeight / 2 - windowHeight / 2 + monitorTop);\n        glfwSetWindowSize(_windowHandle, windowWidth, windowHeight);\n    }\n}\n</code></pre> <p>Few words about what is happening here.</p> <p>As mentioned before I like to keep <code>Initialize</code> and <code>Load</code> separate. <code>Unload</code> as the name suggests unloads any resources to clean up rather then letting the OS take care of that when you ALT+F4 the app.</p> <p>The methods <code>Update</code> and <code>Render</code> are the ones we will be handling our demo/example/guide code in to render stuff and to update things as they are changing.</p> <p><code>OnFramebufferResized</code> is invoked whenever we resize the window. That leads to its framebuffer (the non client recangle area) being resized too and that's where we can hook into; to resize framebuffers or other resources which are depending on the framebuffer size.</p> <p><code>OnKeyDown</code> and <code>OnKeyUp</code> are our callbacks when keys were pressed and released. Should be sufficient for this kind of guide as also mentioned before.</p> <p>We wanted <code>F11</code> to toggle windowed-window and fullscreen, now we can.</p> <p>Basic application is not done yet. Let's also hookup the debug message callback, which will save our butts in the future. Alot of tutorials or blogs keep using so called <code>glCall</code> or <code>glCheck</code> macros which run <code>glGetError</code> - even that they mess up quite a bit, because that ancient function also needs to be called correctly.</p> <p>Anywho.</p> <p>lets extend <code>ApplicationAccess</code> with another method like this</p> <pre><code>static void GLAPIENTRY DebugMessageCallback(GLenum source,\n                                    GLenum type,\n                                    GLuint id,\n                                    GLenum severity,\n                                    [[maybe_unused]] GLsizei length,\n                                    const GLchar* message,\n                                    [[maybe_unused]] const void* userParam)\n{\n    // Ignore certain verbose info messages (particularly ones on Nvidia).\n    if (id == 131169 || \n        id == 131185 || // NV: Buffer will use video memory\n        id == 131218 || \n        id == 131204 || // Texture cannot be used for texture mapping\n        id == 131222 ||\n        id == 131154 || // NV: pixel transfer is synchronized with 3D rendering\n        id == 0         // gl{Push, Pop}DebugGroup\n    )\n    return;\n\n    std::stringstream debugMessageStream;\n    debugMessageStream &lt;&lt; message &lt;&lt; '\\n';\n\n    switch (source)\n    {\n        case GL_DEBUG_SOURCE_API: debugMessageStream &lt;&lt; \"Source: API\"; break;\n        case GL_DEBUG_SOURCE_WINDOW_SYSTEM: debugMessageStream &lt;&lt; \"Source: Window Manager\"; break;\n        case GL_DEBUG_SOURCE_SHADER_COMPILER: debugMessageStream &lt;&lt; \"Source: Shader Compiler\"; break;\n        case GL_DEBUG_SOURCE_THIRD_PARTY: debugMessageStream &lt;&lt; \"Source: Third Party\"; break;\n        case GL_DEBUG_SOURCE_APPLICATION: debugMessageStream &lt;&lt; \"Source: Application\"; break;\n        case GL_DEBUG_SOURCE_OTHER: debugMessageStream &lt;&lt; \"Source: Other\"; break;\n    }\n\n    debugMessageStream &lt;&lt; '\\n';\n\n    switch (type)\n    {\n        case GL_DEBUG_TYPE_ERROR: debugMessageStream &lt;&lt; \"Type: Error\"; break;\n        case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: debugMessageStream &lt;&lt; \"Type: Deprecated Behaviour\"; break;\n        case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: debugMessageStream &lt;&lt; \"Type: Undefined Behaviour\"; break;\n        case GL_DEBUG_TYPE_PORTABILITY: debugMessageStream &lt;&lt; \"Type: Portability\"; break;\n        case GL_DEBUG_TYPE_PERFORMANCE: debugMessageStream &lt;&lt; \"Type: Performance\"; break;\n        case GL_DEBUG_TYPE_MARKER: debugMessageStream &lt;&lt; \"Type: Marker\"; break;\n        case GL_DEBUG_TYPE_PUSH_GROUP: debugMessageStream &lt;&lt; \"Type: Push Group\"; break;\n        case GL_DEBUG_TYPE_POP_GROUP: debugMessageStream &lt;&lt; \"Type: Pop Group\"; break;\n        case GL_DEBUG_TYPE_OTHER: debugMessageStream &lt;&lt; \"Type: Other\"; break;\n    }\n\n    debugMessageStream &lt;&lt; '\\n';\n\n    switch (severity)\n    {\n        case GL_DEBUG_SEVERITY_HIGH: debugMessageStream &lt;&lt; \"Severity: high\"; break;\n        case GL_DEBUG_SEVERITY_MEDIUM: debugMessageStream &lt;&lt; \"Severity: medium\"; break;\n        case GL_DEBUG_SEVERITY_LOW: debugMessageStream &lt;&lt; \"Severity: low\"; break;\n        case GL_DEBUG_SEVERITY_NOTIFICATION: debugMessageStream &lt;&lt; \"Severity: notification\"; break;\n    }\n\n    if (userParam != nullptr)\n    {\n        auto windowHandle = (GLFWwindow*)userParam;\n        auto application = static_cast&lt;Application*&gt;(glfwGetWindowUserPointer(windowHandle));\n        if (application == nullptr)\n        {\n            spdlog::error(\"App: You forgot to call glfwSetWindowUserPointer in Application::Initialize\");\n            return;\n        }\n\n        application-&gt;OnOpenGLDebugMessage(type, debugMessageStream.str());\n    }\n}\n</code></pre> <p>That also means we have to extend <code>Application</code> itself with <code>OnOpenGLDebugMessage</code> like so</p> <pre><code>protected:\n...\nvirtual void OnOpenGLDebugMessage(uint32_t messageType, std::string_view debugMessage);\n...\n</code></pre> <p>and</p> <pre><code>void Application::OnOpenGLDebugMessage(uint32_t messageType, std::string_view debugMessage)\n{\n    spdlog::error(debugMessage);\n    if (messageType == GL_DEBUG_TYPE_ERROR)\n    {\n        debug_break();\n    }\n}\n</code></pre> <p>The <code>Initialize</code> method also needs to be adjusted slightly to hookup the callback and enable the thing.</p> <pre><code>glDebugMessageCallback(ApplicationAccess::DebugMessageCallback, _windowHandle);\nglEnable(GL_DEBUG_OUTPUT);\nglEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);\n</code></pre> <p>So OpenGL has this mechanism which was added as an extension in OpenGL 3.3 or so and is core since 4.3 I believe. A much superior error revealing thing than <code>glGetError</code> ever was. It helps to actually point at the offending function without cluttering your code with those <code>glCall/glCheck</code> macros. and provides a bit more information rather than just \"INVALID HANDLE\" or something like that</p> <p>In this context we are actually only interested in actual errors, thats when we ask the debugger to stop here via <code>debug_break</code>. Then you can take a look at the stacktrace and locate the offending function call that way. With that information you can then go into the glspec And look for the function to figure our how to call it properly.</p> <p>Dont forget to include its header as well</p> <pre><code>#include &lt;debugbreak.h&gt;\n</code></pre> <p>Give it a try, just add a <code>glEnable(0xFFFF);</code> at the end of <code>Application::Initialize</code>. You should get some console output which looks like this:</p> <pre><code>[2023-11-05 23:53:53.768] [error] GL_INVALID_ENUM error generated. &lt;cap&gt; enum is invalid; expected GL_ALPHA_TEST, GL_BLEND, GL_COLOR_MATERIAL, GL_CULL_FACE, GL_DEPTH_TEST, GL_DITHER, GL_FOG, etc. (136 others).\nSource: API\nType: Error\nSeverity: high\n</code></pre>","tags":["GLFW","OpenGL","GLAD"]},{"location":"99910-basic-triangle/10-basic-triangle/","title":"Basic Triangle","text":"<p>Like before in the <code>HelloWindowApplication</code> lets setup the files we need first.</p>"},{"location":"99910-basic-triangle/10-basic-triangle/#hellotrianglebasicapplicationhpp","title":"HelloTriangleBasicApplication.hpp","text":"<pre><code>#pragma once\n\n#include \"../Shared/Application.hpp\"\n\nclass HelloTriangleBasicApplication final : public Application\n{\nprotected:\n    bool Load() override;\n    void Unload() override;\n    void Render() override;\n\nprivate:\n};\n</code></pre>"},{"location":"99910-basic-triangle/10-basic-triangle/#hellotrianglebasicapplicationcpp","title":"HelloTriangleBasicApplication.cpp","text":"<pre><code>#include \"HelloTriangleBasicApplication.hpp\"\n#include \"VertexPositionUv.hpp\"\n\n#include &lt;glad/glad.h&gt;\n#include &lt;spdlog/spdlog.h&gt;\n\n#include &lt;array&gt;\n#include &lt;expected&gt;\n#include &lt;format&gt;\n#include &lt;vector&gt;\n\nbool HelloTriangleBasicApplication::Load()\n{\n    if (!Application::Load())\n    {\n        return false;\n    }\n\n    return true;\n}\n\nvoid HelloTriangleBasicApplication::Unload()\n{\n    Application::Unload();\n}\n\nvoid HelloTriangleBasicApplication::Render()\n{\n}\n</code></pre>"},{"location":"99910-basic-triangle/10-basic-triangle/#maincpp","title":"Main.cpp","text":"<pre><code>#include \"HelloTriangleBasicApplication.hpp\"\n\nint main(int argc, char* argv[])\n{\n    HelloTriangleBasicApplication application;\n    application.Run();\n    return 0;\n}\n</code></pre> <p>To render a triangle we need a shader program, a few vertices and some information to tell the gpu how it all goes together.</p> <p>Shaders are usually stored in some file on disk somewhere, we wont be embedding them in the source code as a string.</p> <p>For that let's extend <code>Application</code> with a method which allows us to read text files, like shaders.</p>"},{"location":"99910-basic-triangle/10-basic-triangle/#applicationhpp","title":"Application.hpp","text":"<pre><code>#include &lt;string_view&gt;\n#include &lt;expected&gt;\n\n// inside the class\nprotected:\n    static std::expected&lt;std::string, std::string&gt; ReadTextFromFile(std::string_view filePath);\n</code></pre>"},{"location":"99910-basic-triangle/10-basic-triangle/#applicationcpp","title":"Application.cpp","text":"<pre><code>#include &lt;fstream&gt;\n#include &lt;format&gt;\n\nstd::expected&lt;std::string, std::string&gt; Application::ReadTextFromFile(std::string_view filePath)\n{\n    std::ifstream file(filePath.data(), std::ios::ate);\n    if (file.bad())\n    {\n        return std::unexpected(std::format(\"Io: Unable to read from file {}\", filePath));\n    }\n    auto fileSize = file.tellg();\n    if (fileSize == 0)\n    {\n        return std::unexpected(std::format(\"Io: File {} is empty\", filePath));\n    }\n\n    std::string result(fileSize, '\\0');\n    file.seekg(0);\n    file.read((char*)result.data(), result.size());\n    return result;\n}\n</code></pre> <p>I suppose now is a good time to mention how <code>OpenGL</code> actually works, at least the bits which are important to get a piece of geometry on screen.</p> Note <p>Explain graphics pipeline in more detail here</p> <p>Vertices are the base information of a mesh/model some geometry. A Vertex usually contains the position and also normal and texture coordinates. Normals can be used for lighting calculations and texture coordinates describe how textures should be stretched across a face/surface, we will also add colors in our first triangle.</p> <p>I will also call texture coordinates from now on Uvs. You will find that convention in the shader files too later.  Its just shorter and more concise... Others might call them <code>tc</code>, <code>texcoord</code>, <code>texcoords</code>, <code>tex_c</code>, <code>texture_coordinates</code> - pain in the ass.</p> <p>Various tutorials also use plain float arrays to describe vertices, which is another weird thing todo, its like writing IBAN as one thing without spaces.</p> <p>Lets fix that by introducing an actual construct called <code>Vertex</code>. Or specifically a <code>VertexPositionColor</code> construct. Since we will be using position AND color data in our example here to describe a vertex.</p> <p>Lets create a <code>VertexPositionColor.hpp</code> file and fill it with</p>"},{"location":"99910-basic-triangle/10-basic-triangle/#vertexpositioncolorhpp","title":"VertexPositionColor.hpp","text":"<pre><code>#pragma once\n\n#include &lt;glm/vec3.hpp&gt;\n\nstruct VertexPositionColor\n{\n    glm::vec3 Position;\n    glm::vec3 Color;\n};\n</code></pre> Glm <p>I believe I mentioned 'glm' before somewhere. It's the vectormaths library we are going to use. It has types for various constructs which come in handy in graphics programming such as vectors, quaternions and matrices.</p> <p>Lets compare that to how other tutorials usually define vertices</p> <pre><code>float vertices[] = {\n    // positions          // colors           // texture coords\n     0.5f,  0.5f, 0.0f,   1.0f, 0.0f, 0.0f,   1.0f, 1.0f,   // top right\n     0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,   1.0f, 0.0f,   // bottom right\n    -0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 1.0f,   0.0f, 0.0f,   // bottom left\n    -0.5f,  0.5f, 0.0f,   1.0f, 1.0f, 0.0f,   0.0f, 1.0f    // top left \n};\n</code></pre> <p>It's weird.</p> <p>In their example they also added uvs into the mix, which is fine. But just formatting this thing to figure out what is what makes no sense in my opinion. Yes the underlying datatype for all those things is <code>float</code>. </p> <p>Luckily <code>GLM</code>'s vec2/3/4 types are also using floats and code should be readable.</p> <p>As an exercise, try to \"convert\" LearnOpenGL's vertex from above into a <code>VertexPositionColorUv</code> construct.</p> <p>Besides a proper vertex format, what else do we need to get a tringle on screen?</p> <p>Perhaps I should show a picture of a typical/simple graphics pipeline, which consists of a few boxes.</p> <p> (stolen from here - kind of the only picture which doesnt include obsolete/irrelevant stages and I was too lazy to draw my own version)</p> <p>As you can see its a few steps, involved to cook up pixels on a screen.</p>"},{"location":"99910-basic-triangle/10-basic-triangle/#input-layout","title":"Input Layout","text":"<p>The first stage is where we send the vertices and indices into the input assembly. That's the place which needs to know how to interpret the vertices and indices. Or in other words how they are layed out in the buffer. That is the reason why I would like to go with the name of <code>Input Layout</code> which makes more sense in my head than what OpenGL calls the construct to describe the layout. OpenGL calls that thing <code>Vertex Array Object</code>, it's also quite often just called <code>VAO</code>. VAO Makes no sense in my smal frog brain. Therefore we will go with <code>Input Layout</code> or perhaps <code>IL</code> from here.</p> <p>Let's fiddle it into our example project.</p> <p>We need to declare 3 things in <code>HelloTriangleBasicApplication.hpp</code>. </p> <pre><code>private:\n    uint32_t _inputLayout = 0;\n    uint32_t _vertexBuffer = 0;\n    uint32_t _indexBuffer = 0;\n</code></pre> <p>All the following code snippets besides the vertex shader code, go right after in <code>HelloTriangleBasicApplication.cpp</code></p> <pre><code>bool HelloTriangleBasicApplication::Load()\n{\n    if (!Application::Load())\n    {\n        return false;\n    }\n</code></pre> <pre><code>glCreateVertexArrays(1, &amp;_inputLayout);\nauto label = \"InputLayout_Simple\";\nglObjectLabel(GL_VERTEX_ARRAY, _inputLayout, label.size(), label.data());\n\nglEnableVertexArrayAttrib(_inputLayout, 0);\nglVertexArrayAttribFormat(_inputLayout, 0, 3, GL_FLOAT, GL_FALSE, offsetof(VertexPositionColor, Position));\nglVertexArrayAttribBinding(_inputLayout, 0, 0);\n\nglEnableVertexArrayAttrib(_inputLayout, 1);\nglVertexArrayAttribFormat(_inputLayout, 1, 3, GL_FLOAT, GL_FALSE, offsetof(VertexPositionColor, Color));\nglVertexArrayAttribBinding(_inputLayout, 1, 0);\n</code></pre> <p>As you can see \"VertexArray\"this \"VertexArray\"that. The only \"Vertex Array\" which makes sense is the buffer containing the actual vertices... which we will come to in a sec. But try to make sense of this.</p> <p>We create the input layout first and then we describe its format with the 2 sets of 3 function calls.</p> <p>I also smuggled in a little helper, <code>glObjectLabel</code>, which I will also explain later, I can tell you that much already its a useful tool.</p> <p>When you squint your eyes a little you can probably see a pattern emerging when looking at the glEnable..glVertexArrayAttrib... calls. They refer to attribute indices or locations. Like \"Attribute Location 0 should be a type with 3 float components and its offset is 0 and \"Attribute location 1 should be a type with 3 float components and its offset should be whatever size Position is within the VertexPositionColor construct - probably 3xfloat = 3xsizeof(float = 3x4 = 12)</p> <p>Thats what the ...AttribFormat call is there for. The ..AttribBinding defines to what bound vertex buffer that format is related to (we use only 1 vertex buffer here, therefore its 0) Enable...Attrib as the name suggests enables that attribute for that specific input layout. Attributes can be enabled/disabled dynamically and that is useful when you want to live on the just one Ping Vasily just one VAO for everything path, where you dynamically enable/disable attributes on the fly where needed. I prefer individual input layout objects for my graphics pipelines though.</p> <p>Do you remember the exercise where I asked you to cook up <code>VertexPositionColorUv</code>? Perhaps you can figure out how the input layout should be defined for that format.</p> <p>Another important thing here is the vertex stage which is the next one after the input assembly. That's where the vertex shader comes into play. Let me toss the first part of the vertex shader in here to see...</p> <pre><code>#version 460 core\n\nlayout(location = 0) in vec3 i_position;\nlayout(location = 1) in vec3 i_color;\n\nlayout (location = 0) out gl_PerVertex\n{\n...\n</code></pre> <p>Funny how the vertex shader has VERY similar looking input attributes, neh? Coincidence? No.</p> <p>You can see here, 2 input attributes. One of type vec3 which reads as \"type of float which consist of 3 components\" and another one also of \"type of float with consists of 3 components\". Literally sounds the same as we just did with the gl...AttribFormat.</p> <p>The important bit here is, the input layout should match the vertex shader input (the attributes which start with <code>in</code>)</p> <p>The vertex shader also transforms our vertices so that they can appear properly on screen.</p> <p>Coordinate Systems/Vertex Transformation</p> <p>Not sure if I want to explain or steal/link it from/to somewhere else, probably should do the latter</p> <p>Lets create the vertex and index buffers for our triangle</p>"},{"location":"99910-basic-triangle/10-basic-triangle/#vertexbuffer","title":"VertexBuffer","text":"<pre><code>std::array&lt;VertexPositionColor, 3&gt; vertices =\n{\n    VertexPositionColor{ .Position = glm::vec3(-0.5f, +0.5f, 0.0f), .Color = glm::vec3(1.0f, 0.2f, 1.0f) },\n    VertexPositionColor{ .Position = glm::vec3(+0.0f, -0.5f, 0.0f), .Color = glm::vec3(0.2f, 1.0f, 1.0f) },\n    VertexPositionColor{ .Position = glm::vec3(+0.5f, +0.5f, 0.0f), .Color = glm::vec3(1.0f, 1.0f, 0.2f) }        \n};\n\nglCreateBuffers(1, &amp;_vertexBuffer);\nlabel = \"VertexBuffer_Triangle\";\nglObjectLabel(GL_BUFFER, _vertexBuffer, label.size(), label.data());\nglNamedBufferData(_vertexBuffer, vertices.size() * sizeof(VertexPositionColor), vertices.data(), GL_STATIC_DRAW);\n</code></pre>"},{"location":"99910-basic-triangle/10-basic-triangle/#indexbuffer","title":"IndexBuffer","text":"<pre><code>std::array&lt;uint32_t, 3&gt; indices = { 0, 1, 2 };\n\nglCreateBuffers(1, &amp;_indexBuffer);\nlabel = \"IndexBuffer_Triangle\";\nglObjectLabel(GL_BUFFER, _vertexBuffer, label.size(), label.data());\nglNamedBufferData(_indexBuffer, indices.size() * sizeof(uint32_t), indices.data(), GL_STATIC_DRAW);\n</code></pre> <p>Simple, Triangle has 3 vertices, you create a buffer object and add 3 of them to the vertex buffer, with telling them where to place and how to color them.</p> <p>Similar to indices. Since we want to draw triangles we need 3 of them, also in their dedicated buffer.</p> <p>Indices???</p> <p>Indices make vertex reuse possible, by indexing into the vertices instead of providing vertices for each and every vertex. Nice I explained Bratwurst with Bratwurst. In this specific case we would not need indices at all, because not a single vertex is or was reused, Indices make sense when you want/can reuse vertices in models which is quite often the case.</p> <p>To make the connection between the buffers and the input layout, since that has to be a thing, we call 2 more functions</p> <pre><code>glVertexArrayVertexBuffer(_inputLayout, 0, _vertexBuffer, 0, sizeof(VertexPositionColor));\nglVertexArrayElementBuffer(_inputLayout, _indexBuffer);\n</code></pre> <p>First call tells the input layout \"hey use this buffer for binding 0\" (that binding we passed in those <code>glVertex...AttribBinding</code> calls, if you remember) and the stride of the vertices is the size of the vertex we made up, so that the offset part makes sense in those <code>glVertex..AttribFormat</code> calls</p> <p>Second call hooks up the indexbuffer to the input layout.</p> <p>Within the current folder, create a <code>Data/Shaders</code> folder and copy paste the vertex and fragment shader in there</p>"},{"location":"99910-basic-triangle/10-basic-triangle/#simplevsglsl","title":"Simple.vs.glsl","text":"<pre><code>#version 460 core\n\nlayout(location = 0) in vec3 i_position;\nlayout(location = 1) in vec3 i_color;\n\nlayout (location = 0) out gl_PerVertex\n{\n    vec4 gl_Position;\n};\nlayout(location = 0) out vec3 v_color;\n\nvoid main()\n{\n    gl_Position = vec4(i_position, 1.0);\n    v_color = i_color;\n}\n</code></pre>"},{"location":"99910-basic-triangle/10-basic-triangle/#simplefsglsl","title":"Simple.fs.glsl","text":"<pre><code>#version 460 core\n\nlayout(location = 0) in vec3 v_color;\n\nlayout(location = 0) out vec4 o_color;\n\nvoid main()\n{\n    o_color = vec4(v_color, 1.0f);\n}\n</code></pre> <p>tbd</p>"}]}